# Author: OpenAI Assistant
help:
  text   : Provides precise time retrieval (system or atomic clock), timezone intelligence, and delay controls over STDIO/HTTP MCP.
  expects:
  - name     : onport
    desc     : Optional HTTP port. When omitted the MCP server runs over STDIO.
    example  : "8888"
    mandatory: false

todo:
- (if    ): "isDef(args.onport)"
  ((then)):
  - (httpdStart   ): "${onport:-8080}"
  - (httpdHealthz ): "${onport:-8080}"
  - (httpdMetrics ): "${onport:-8080}"
  - (httpdMCP     ): "${onport:-8080}"
    ((description)): &MCPSERVER
      serverInfo:
        name   : mini-a-time
        title  : OpenAF mini-a precision time MCP server
        version: 1.1.0
    ((fnsMeta)): &MCPFNSMETA
      current-time:
        name       : current-time
        description: Returns detailed current time data from the system clock or an atomic clock, with formatting and timezone controls.
        inputSchema:
          type      : object
          properties:
            timezone:
              type        : string
              description : IANA timezone identifier used instead of the system default.
              example     : "Europe/Lisbon"
            format:
              type        : string
              description : Java time pattern used for the `formatted` field (defaults to ISO timestamps).
              example     : "yyyy-MM-dd HH:mm:ss"
            locale:
              type        : string
              description : BCP 47 language tag applied to locale-aware formatting.
              example     : "en-US"
            timeSource:
              type        : string
              description : Selects which clock to trust. Use `system` for JVM time or `atomic` to query NTP/atomic sources.
              enum        : [ system, atomic ]
              example     : "atomic"
            ntpServer:
              type        : string
              description : Optional NTP server hostname used when `timeSource` is atomic (defaults to pool rotation).
              example     : "time.google.com"
            ntpTimeoutMs:
              type        : integer
              minimum     : 1
              description : Timeout in milliseconds when requesting atomic time.
              example     : 4000
          required: []
        annotations:
          title         : precise-current-time
          readOnlyHint  : true
          idempotentHint: true

      timezone-tools:
        name       : timezone-tools
        description: Converts timestamps, compares offsets, or lists zones depending on the requested operation.
        inputSchema:
          type      : object
          properties:
            operation:
              type        : string
              description : "Operation to perform: `convert`, `difference`, or `list`."
              enum        : [ convert, difference, list ]
            targetTimezone:
              type        : string
              description : Target IANA timezone identifier (required for `convert`).
              example     : "America/New_York"
            sourceTimezone:
              type        : string
              description : Source IANA timezone identifier (defaults to the system timezone).
              example     : "Europe/Lisbon"
            datetime:
              type        : string
              description : Date/time reference for `convert`/`difference`. Supports ISO 8601, LocalDateTime strings, or Unix epoch (10-digit seconds, 13-digit milliseconds, negative for pre-1970). Defaults to now.
              example     : "2024-06-01T10:15:00"
            inputFormat:
              type        : string
              description : Optional Java time pattern when parsing datetimes without timezone offsets.
              example     : "yyyy-MM-dd'T'HH:mm:ss"
            outputFormat:
              type        : string
              description : Java time pattern used to format the convert output.
              example     : "EEE, dd MMM yyyy HH:mm z"
            firstTimezone:
              type        : string
              description : First IANA timezone identifier (required for `difference`).
              example     : "Europe/London"
            secondTimezone:
              type        : string
              description : Second IANA timezone identifier (required for `difference`).
              example     : "Asia/Tokyo"
            locale:
              type        : string
              description : Optional BCP 47 language tag applied to parsing/formatting (convert/difference).
              example     : "en-US"
            search:
              type        : string
              description : Case-insensitive substring filter used when listing timezones.
              example     : "America"
          required: [ operation ]
        annotations:
          title         : timezone-operations
          readOnlyHint  : true
          idempotentHint: true
      sleep:
        name       : sleep
        description: Pauses execution for controlled delays (useful for pacing prompts or demos).
        inputSchema:
          type      : object
          properties:
            milliseconds:
              type        : integer
              minimum     : 0
              description : Number of milliseconds to pause execution.
              example     : 1000
          required: [ milliseconds ]
        annotations:
          title         : delay
          readOnlyHint  : false
          idempotentHint: false
    ((fns    )): &MCPFNS
      current-time   : Current time information
      timezone-tools : Timezone utilities
      sleep          : Sleep
  ((else)):
  - (stdioMCP ): *MCPSERVER
    ((fnsMeta)): *MCPFNSMETA
    ((fns    )): *MCPFNS

ojob:
  opacks      :
  - openaf     : 20250915
  - oJob-common: 20250914
  catch       : printErrnl("[" + job.name + "] "); $err(exception, __, __, job.exec)
  logToConsole: false   # to change when finished
  argsFromEnvs: true
  daemon      : true
  unique      :
    pidFile     : .mcp-time.pid
    killPrevious: true

include:
- oJobMCP.yaml

jobs:
# -------------------------------
- name : Current time information
  check:
    in:
      timezone   : isString.default(__)
      format     : isString.default(__)
      locale     : isString.default(__)
      timeSource : isString.default(__)
      ntpServer  : isString.default(__)
      ntpTimeoutMs: isNumber.default(__)
  exec : | #js
    var ZoneId = java.time.ZoneId
    var ZonedDateTime = java.time.ZonedDateTime
    var Instant = java.time.Instant
    var DateTimeFormatter = java.time.format.DateTimeFormatter
    var ChronoUnit = java.time.temporal.ChronoUnit
    var IsoFields = java.time.temporal.IsoFields
    var TextStyle = java.time.format.TextStyle
    var Locale = java.util.Locale

    var zone = isDef(args.timezone) ? ZoneId.of(args.timezone) : ZoneId.systemDefault()
    var locale = isDef(args.locale) ? Locale.forLanguageTag(args.locale) : Locale.getDefault()
    var source = isDef(args.timeSource) ? String(args.timeSource).toLowerCase() : "system"
    var allowedSources = ["system", "atomic"]
    if (allowedSources.indexOf(source) < 0) {
      throw new Error("timeSource must be 'system' or 'atomic'")
    }

    var atomicServer = (isDef(args.ntpServer) && String(args.ntpServer).trim().length > 0) ? String(args.ntpServer).trim() : __
    var atomicTimeout = isDef(args.ntpTimeoutMs) ? Number(args.ntpTimeoutMs) : __
    var currentInstant

    if (source === "atomic") {
      ow.loadNet()

      try {
        if (isDef(atomicServer) && isDef(atomicTimeout)) {
          currentInstant = Instant.ofEpochMilli(ow.net.getActualTime(atomicServer, atomicTimeout).getTime())
        } else if (isDef(atomicServer)) {
          currentInstant = Instant.ofEpochMilli(ow.net.getActualTime(atomicServer).getTime())
        } else if (isDef(atomicTimeout)) {
          currentInstant = Instant.ofEpochMilli(ow.net.getActualTime(__, atomicTimeout).getTime())
        } else {
          currentInstant = Instant.ofEpochMilli(ow.net.getActualTime().getTime())
        }
      } catch(e) {
        throw new Error("Unable to obtain atomic clock time: " + e)
      }
    } else {
      currentInstant = Instant.now()
    }

    var now = ZonedDateTime.ofInstant(currentInstant, zone)

    var pattern = isDef(args.format) ? args.format : "yyyy-MM-dd'T'HH:mm:ssXXX"
    var formatter = DateTimeFormatter.ofPattern(pattern).withLocale(locale)
    var timeFormatter = DateTimeFormatter.ofPattern("HH:mm:ss").withLocale(locale)

    var truncated = now.truncatedTo(ChronoUnit.SECONDS)
    var weekOfYear = now.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR)
    var weekYear = now.get(IsoFields.WEEK_BASED_YEAR)

    var offsetSeconds = Number(now.getOffset().getTotalSeconds())

    var result = {
      timezone              : String(zone.getId()),
      timezoneDisplay       : String(zone.getDisplayName(TextStyle.FULL, locale)),
      timezoneAbbreviation  : String(zone.getDisplayName(TextStyle.SHORT, locale)),
      offset                : String(now.getOffset()),
      offsetSeconds         : offsetSeconds,
      offsetHours           : Number(offsetSeconds / 3600),
      iso8601               : String(now.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
      zonedISO              : String(now.format(DateTimeFormatter.ISO_ZONED_DATE_TIME)),
      formatted             : String(now.format(formatter)),
      date                  : String(now.toLocalDate()),
      time                  : String(truncated.format(timeFormatter)),
      unixEpochSeconds      : Number(now.toEpochSecond()),
      unixEpochMilliseconds : Number(now.toInstant().toEpochMilli()),
      dayOfWeek             : String(now.getDayOfWeek()),
      dayOfYear             : Number(now.getDayOfYear()),
      weekOfYear            : Number(weekOfYear),
      weekYear              : Number(weekYear),
      isDaylightSaving      : Boolean(zone.getRules().isDaylightSavings(now.toInstant())),
      locale                : String(locale.toLanguageTag()),
      timeSource            : String(source)
    }

    if (source === "atomic") {
      if (isDef(atomicServer)) {
        result.ntpServer = String(atomicServer)
      }
      if (isDef(atomicTimeout)) {
        result.ntpTimeoutMs = Number(atomicTimeout)
      }
    }

    return result

# -------------------------
- name : Timezone utilities
  check:
    in:
      operation     : isString
      targetTimezone: isString.default(__)
      sourceTimezone: isString.default(__)
      datetime      : isString.default(__)
      inputFormat   : isString.default(__)
      outputFormat  : isString.default(__)
      firstTimezone : isString.default(__)
      secondTimezone: isString.default(__)
      locale        : isString.default(__)
      search        : isString.default(__)
  exec : | #js
    var allowedOps = ["convert", "difference", "list"]
    var op = isDef(args.operation) ? String(args.operation).toLowerCase() : null
    if (isUnDef(op) || allowedOps.indexOf(op) < 0) {
      throw new Error("operation must be one of convert, difference, list")
    }

    if (op === "list") {
      var ZoneIdList = java.time.ZoneId
      var zones = ZoneIdList.getAvailableZoneIds().iterator()
      var list = []
      while (zones.hasNext()) {
        var id = String(zones.next())
        if (isDef(args.search)) {
          if (id.toLowerCase().indexOf(String(args.search).toLowerCase()) >= 0) {
            list.push(id)
          }
        } else {
          list.push(id)
        }
      }
      list.sort()
      return {
        operation : op,
        timezones : list
      }
    }

    var ZoneId = java.time.ZoneId
    var ZonedDateTime = java.time.ZonedDateTime
    var LocalDateTime = java.time.LocalDateTime
    var DateTimeFormatter = java.time.format.DateTimeFormatter
    var Instant = java.time.Instant
    var Locale = java.util.Locale
    var locale = isDef(args.locale) ? Locale.forLanguageTag(args.locale) : Locale.getDefault()

    function parseEpochToZoned(value, zone) {
      if (isUnDef(value) || value === null) return __

      var raw = String(value).trim()
      if (raw.length === 0) return __
      if (!/^-?\d+$/.test(raw)) return __

      var epoch = Number(raw)
      if (!isFinite(epoch)) return __

      // 13+ digits usually represent milliseconds; smaller magnitudes are treated as seconds.
      var instant = Math.abs(epoch) >= 1000000000000 ? Instant.ofEpochMilli(Math.trunc(epoch)) : Instant.ofEpochSecond(Math.trunc(epoch))
      return ZonedDateTime.ofInstant(instant, zone)
    }

    if (op === "convert") {
      if (isUnDef(args.targetTimezone)) {
        throw new Error("targetTimezone is required for operation=convert")
      }

      var sourceZone = isDef(args.sourceTimezone) ? ZoneId.of(args.sourceTimezone) : ZoneId.systemDefault()
      var targetZone = ZoneId.of(args.targetTimezone)
      var formatterOut = isDef(args.outputFormat) ? DateTimeFormatter.ofPattern(args.outputFormat).withLocale(locale) : null

      function parseDateTime(value) {
        if (isUnDef(value) || value === null || value === "") {
          return ZonedDateTime.now(sourceZone)
        }

        // Detect numeric epoch input (Unix timestamps)
        // Supports both seconds (10 digits) and milliseconds (13 digits)
        // Also supports negative epoch values for historical dates before 1970
        if (/^-?\d+$/.test(value)) {
          var Instant = java.time.Instant
          // Extract digit count (excluding the optional minus sign)
          var digitCount = value.startsWith('-') ? value.length - 1 : value.length
          
          // 10-digit value indicates seconds since epoch
          if (digitCount === 10) {
            return ZonedDateTime.ofInstant(Instant.ofEpochSecond(Number(value)), sourceZone)
          }
          // 13-digit value indicates milliseconds since epoch
          else if (digitCount === 13) {
            return ZonedDateTime.ofInstant(Instant.ofEpochMilli(Number(value)), sourceZone)
          }
          // Invalid epoch format - must be 10 or 13 digits
          throw new Error("Epoch value must be 10 or 13 digits (seconds or milliseconds).")
        }

        if (isDef(args.inputFormat)) {
          var fmt = DateTimeFormatter.ofPattern(args.inputFormat).withLocale(locale)
          var local = LocalDateTime.parse(value, fmt)
          return local.atZone(sourceZone)
        }

        try {
          return ZonedDateTime.parse(value)
        } catch(e) {
          var local = LocalDateTime.parse(value)
          return local.atZone(sourceZone)
        }
      }

      var parsed = parseDateTime(args.datetime)
      var converted = parsed.withZoneSameInstant(targetZone)

      return {
        operation            : op,
        sourceTimezone       : String(sourceZone.getId()),
        targetTimezone       : String(targetZone.getId()),
        sourceIso8601        : String(parsed.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
        targetIso8601        : String(converted.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
        targetZonedISO       : String(converted.format(DateTimeFormatter.ISO_ZONED_DATE_TIME)),
        formatted            : formatterOut ? String(converted.format(formatterOut)) : String(converted.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
        sourceOffsetSeconds  : Number(parsed.getOffset().getTotalSeconds()),
        targetOffsetSeconds  : Number(converted.getOffset().getTotalSeconds()),
        unixEpochSeconds     : Number(converted.toEpochSecond()),
        unixEpochMilliseconds: Number(converted.toInstant().toEpochMilli())
      }
    }

    if (op === "difference") {
      if (isUnDef(args.firstTimezone) || isUnDef(args.secondTimezone)) {
        throw new Error("firstTimezone and secondTimezone are required for operation=difference")
      }

      var firstZone = ZoneId.of(args.firstTimezone)
      var secondZone = ZoneId.of(args.secondTimezone)

      function parseMoment(value) {
        if (isUnDef(value) || value === null || value === "") {
          return ZonedDateTime.now(firstZone)
        }

        var epochParsed = parseEpochToZoned(value, firstZone)
        if (isDef(epochParsed)) return epochParsed

        if (isDef(args.inputFormat)) {
          var fmt = DateTimeFormatter.ofPattern(args.inputFormat).withLocale(locale)
          var local = LocalDateTime.parse(value, fmt)
          return local.atZone(firstZone)
        }

        try {
          return ZonedDateTime.parse(value)
        } catch(e) {
          var local = LocalDateTime.parse(value)
          return local.atZone(firstZone)
        }
      }

      var base = parseMoment(args.datetime)
      var instant = base.toInstant()

      var firstOffset = firstZone.getRules().getOffset(instant).getTotalSeconds()
      var secondOffset = secondZone.getRules().getOffset(instant).getTotalSeconds()
      var differenceSeconds = secondOffset - firstOffset
      var totalMinutes = Math.abs(differenceSeconds) / 60
      var hours = Math.floor(totalMinutes / 60)
      var minutes = Math.floor(totalMinutes % 60)

      function pad2(value) {
        var str = String(value)
        return str.length < 2 ? ("0" + str).slice(-2) : str
      }
      var formattedDifference = (differenceSeconds >= 0 ? "+" : "-") + pad2(hours) + ":" + pad2(minutes)

      return {
        operation           : op,
        referenceIso8601    : String(base.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)),
        firstTimezone       : String(firstZone.getId()),
        secondTimezone      : String(secondZone.getId()),
        firstOffsetSeconds  : Number(firstOffset),
        secondOffsetSeconds : Number(secondOffset),
        differenceSeconds   : Number(differenceSeconds),
        differenceHours     : Number(differenceSeconds / 3600),
        differenceFormatted : formattedDifference
      }
    }

    throw new Error("Unsupported operation: " + op)

# ------------
- name : Sleep
  check:
    in:
      milliseconds: isNumber
  exec : | #js
    var duration = Number(args.milliseconds)
    if (!isFinite(duration) || duration < 0) {
      throw new Error("milliseconds must be a non-negative number")
    }

    sleep(duration, true)

    return {
      sleptMilliseconds: duration
    }
