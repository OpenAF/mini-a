# Author: Nuno Aguiar
# License: Apache 2.0
# Description: Mini-A headless worker API for programmatic agent delegation

help:
  text   : Mini-A headless worker API for programmatic agent delegation between processes/containers/hosts
  expects:
  - name     : onport
    desc     : API server port
    example  : "8080"
    mandatory: false
  - name     : apitoken
    desc     : Required bearer token for authentication
    example  : "your-secret-token"
    mandatory: false
  - name     : apiallow
    desc     : Comma-separated IP allowlist
    example  : "127.0.0.1,192.168.1.0/24"
    mandatory: false
  - name     : maxconcurrent
    desc     : Maximum concurrent tasks
    example  : "4"
    mandatory: false
  - name     : defaulttimeout
    desc     : Default task deadline in milliseconds
    example  : "300000"
    mandatory: false
  - name     : maxtimeout
    desc     : Maximum allowed task deadline in milliseconds
    example  : "600000"
    mandatory: false
  - name     : taskretention
    desc     : Seconds to keep completed task results
    example  : "3600"
    mandatory: false
  - name     : workername
    desc     : Worker name reported by /info
    example  : "mini-a-worker"
    mandatory: false
  - name     : workerdesc
    desc     : Worker description reported by /info
    example  : "US-East research worker"
    mandatory: false
  - name     : workerregurl
    desc     : Comma-separated list of main instance registration URLs
    example  : "http://main1:12345,http://main2:12345"
    mandatory: false
  - name     : workerregtoken
    desc     : Bearer token for authenticating with registration endpoints
    example  : "your-reg-token"
    mandatory: false
  - name     : workerreginterval
    desc     : Heartbeat interval in milliseconds
    example  : "30000"
    mandatory: false

include:
- oJobHTTPd.yaml

todo:
- Init

# --- HTTP server lifecycle ---
- (httpdStart  ): "${onport:-8888}"
- (httpdHealthz): "${onport:-8888}"
- (httpdMetrics): "${onport:-8888}"
#- (httpdStop ): "${onport:-8888}"

# --- Public endpoints ---
- (httpdService): "${onport:-8888}"
  ((uri       )): /info
  ((execURI   )): | #js
    var wargs = global.__worker_args;
    var response = {
      status: "ok",
      name: isString(wargs.workername) ? wargs.workername : "mini-a-worker",
      description: isString(wargs.workerdesc) ? wargs.workerdesc : "Mini-A worker API",
      version: "1.0.0",
      capabilities: ["run-goal", "delegation", "planning", "a2a-http-json-rest"],
      limits: {
        maxConcurrent: wargs.maxconcurrent,
        defaultTimeoutMs: wargs.defaulttimeout,
        maxTimeoutMs: wargs.maxtimeout,
        maxSteps: wargs.maxsteps || 15,
        useshell: toBoolean(wargs.useshell) || false
      },
      auth: isDef(wargs.apitoken) ? "bearer" : "none"
    };
    return ow.server.httpd.reply(stringify(response, __, ""), __, ow.server.httpd.mimes.JSON);
  ((error    )): true


- (httpdService): "${onport:-8888}"
  ((uri       )): /.well-known/agent.json
  ((execURI   )): | #js
    var wargs = global.__worker_args;
    var baseUrl = "http://" + ow.net.getHostAddress() + ":" + wargs.onport;
    var card = {
      protocolVersion: "0.3.0",
      name: isString(wargs.workername) ? wargs.workername : "mini-a-worker",
      description: isString(wargs.workerdesc) ? wargs.workerdesc : "Mini-A worker API",
      url: baseUrl,
      preferredTransport: "HTTP+JSON",
      additionalInterfaces: ["mini-a-worker-v1"],
      capabilities: {
        streaming: false,
        pushNotifications: false,
        stateTransitionHistory: true
      },
      skills: [
        {
          id: "run-goal",
          name: "Run goal",
          description: "Executes Mini-A goals asynchronously and returns task results",
          tags: ["planning", "delegation", "research"],
          examples: ["Summarize this document", "Create a release checklist"]
        }
      ]
    };
    return ow.server.httpd.reply(stringify(card, __, ""), __, ow.server.httpd.mimes.JSON);
  ((error    )): true

# --- Authenticated endpoints ---
- (httpdService): "${onport:-8888}"
  ((uri       )): /task
  ((execPre   )): &authCheck | #js
    if (isDef(global.__worker_args.apitoken)) {
      var authHeader = request.header.authorization || "";
      if (authHeader !== "Bearer " + global.__worker_args.apitoken) {
        return ow.server.httpd.reply(stringify({ error: "Unauthorized" }, __, ""), 401, ow.server.httpd.mimes.JSON);
      }
    }
    if (isArray(global.__worker_ipallow) && global.__worker_ipallow.length > 0) {
      var remoteAddr = request.header["x-forwarded-for"] || request.remoteAddress;
      var allowed = global.__worker_ipallow.some(function(pattern) { return remoteAddr.indexOf(pattern) === 0; });
      if (!allowed) {
        return ow.server.httpd.reply(stringify({ error: "Forbidden" }, __, ""), 403, ow.server.httpd.mimes.JSON);
      }
    }
  ((execURI  )): | #js
    try {
      var postData;
      try { postData = jsonParse(request.files.postData); } catch(jsonErr) {
        return ow.server.httpd.reply(stringify({ error: "Invalid JSON in request body" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var wargs = global.__worker_args;
      var goalTrimmed = isString(postData.goal) ? postData.goal.trim() : "";
      if (goalTrimmed.length === 0) {
        return ow.server.httpd.reply(stringify({ error: "Missing required field: goal" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      if (goalTrimmed.length > 10000) {
        return ow.server.httpd.reply(stringify({ error: "Goal exceeds maximum length of 10000 characters" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var taskArgs = postData.args || {};
      var allowedRemoteKeys = {
        goal: true, format: true, raw: true, chatbotmode: true, useplanning: true,
        updatefreq: true, updateinterval: true, forceupdates: true, planlog: true,
        planmode: true, planformat: true, convertplan: true, maxsteps: true
      };
      var mergedArgs = merge({}, wargs);
      Object.keys(taskArgs).forEach(function(key) {
        if (allowedRemoteKeys[key] === true) { mergedArgs[key] = taskArgs[key]; }
      });
      mergedArgs.goal = goalTrimmed;
      var timeout = wargs.defaulttimeout;
      if (isDef(postData.timeout)) {
        var parsedTimeout = Number(postData.timeout);
        if (!isNaN(parsedTimeout) && parsedTimeout > 0) {
          timeout = parsedTimeout * 1000;
        }
      }
      if (timeout > wargs.maxtimeout) timeout = wargs.maxtimeout;
      var taskId = genUUID();
      var now = new Date().getTime();
      if (isUnDef(global.__worker_taskManager)) {
        global.__worker_taskManager = new SubtaskManager(mergedArgs, {
          maxConcurrent: wargs.maxconcurrent,
          defaultDeadlineMs: wargs.defaulttimeout,
          defaultMaxAttempts: wargs.delegationmaxretries,
          maxDepth: wargs.delegationmaxdepth,
          interactionFn: function(event, message) {
            var resolvedTaskId = global.__worker_resolveTaskIdFromMessage(message);
            if (isString(resolvedTaskId) && resolvedTaskId.length > 0) {
              global.__worker_appendTaskEvent(resolvedTaskId, event, message);
            }
            global.__worker_logTaskEvent(resolvedTaskId, event, message);
          },
          currentDepth: 0
        });
      }
      var subtaskId = global.__worker_taskManager.submit(mergedArgs.goal, mergedArgs, {
        deadlineMs: timeout,
        metadata: postData.metadata || {}
      });
      global.__worker_tasks[taskId] = {
        taskId: taskId, subtaskId: subtaskId, status: "queued", goal: mergedArgs.goal,
        args: mergedArgs, createdAt: now, startedAt: __, completedAt: __,
        events: [], metadata: postData.metadata || {}
      };
      global.__worker_subtaskToTaskId[subtaskId] = taskId;
      global.__worker_subtaskShortToTaskId[subtaskId.substring(0, 8)] = taskId;
      global.__worker_logTaskEvent(taskId, "info", "[subtask:" + subtaskId.substring(0, 8) + "] Task accepted by worker");
      global.__worker_taskManager.start(subtaskId);
      global.__worker_tasks[taskId].status = "running";
      global.__worker_tasks[taskId].startedAt = new Date().getTime();
      return ow.server.httpd.reply(stringify({ taskId: taskId, status: "queued", createdAt: now }, __, ""), 202, ow.server.httpd.mimes.JSON);
    } catch(e) {
      logErr(e);
      return ow.server.httpd.reply(stringify({ error: String(e) }, __, ""), 500, ow.server.httpd.mimes.JSON);
    }
  ((error    )): true


- (httpdService): "${onport:-8888}"
  ((uri       )): /message:send
  ((execPre   )): *authCheck
  ((execURI   )): | #js
    try {
      var postData;
      try { postData = jsonParse(request.files.postData); } catch(jsonErr) {
        return ow.server.httpd.reply(stringify({ error: "Invalid JSON in request body" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var message = isMap(postData.message) ? postData.message : {};
      var goal = "";
      if (isArray(message.parts)) {
        goal = message.parts.map(function(part) {
          if (isMap(part) && isString(part.text)) return part.text;
          return "";
        }).filter(function(part) { return part.length > 0; }).join("\n");
      }
      if ((!isString(goal) || goal.trim().length === 0) && isString(postData.goal)) goal = postData.goal;
      if (!isString(goal) || goal.trim().length === 0) {
        return ow.server.httpd.reply(stringify({ error: "Missing required message text" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }

      var taskPayload = {
        goal: goal,
        args: isMap(postData.metadata) ? postData.metadata.args : {},
        timeout: isMap(postData.configuration) ? postData.configuration.timeoutSeconds : __,
        metadata: {
          a2aMessageId: isString(message.messageId) ? message.messageId : __,
          a2aContextId: isString(postData.contextId) ? postData.contextId : __
        }
      };

      var requestBody = { files: { postData: stringify(taskPayload, __, "") } };
      var _request = request;
      request = requestBody;
      var submission = __;
      try {
        submission = (function() {
          var postData;
          postData = jsonParse(request.files.postData);
          var wargs = global.__worker_args;
          var goalTrimmed = isString(postData.goal) ? postData.goal.trim() : "";
          var taskArgs = postData.args || {};
          var allowedRemoteKeys = {
            goal: true, format: true, raw: true, chatbotmode: true, useplanning: true,
            updatefreq: true, updateinterval: true, forceupdates: true, planlog: true,
            planmode: true, planformat: true, convertplan: true, maxsteps: true
          };
          var mergedArgs = merge({}, wargs);
          Object.keys(taskArgs).forEach(function(key) {
            if (allowedRemoteKeys[key] === true) { mergedArgs[key] = taskArgs[key]; }
          });
          mergedArgs.goal = goalTrimmed;
          var timeout = wargs.defaulttimeout;
          if (isDef(postData.timeout)) {
            var parsedTimeout = Number(postData.timeout);
            if (!isNaN(parsedTimeout) && parsedTimeout > 0) timeout = parsedTimeout * 1000;
          }
          if (timeout > wargs.maxtimeout) timeout = wargs.maxtimeout;
          var taskId = genUUID();
          var now = new Date().getTime();
          if (isUnDef(global.__worker_taskManager)) {
            global.__worker_taskManager = new SubtaskManager(mergedArgs, {
              maxConcurrent: wargs.maxconcurrent,
              defaultDeadlineMs: wargs.defaulttimeout,
              defaultMaxAttempts: wargs.delegationmaxretries,
              maxDepth: wargs.delegationmaxdepth,
              interactionFn: function(event, message) {
                var resolvedTaskId = global.__worker_resolveTaskIdFromMessage(message);
                if (isString(resolvedTaskId) && resolvedTaskId.length > 0) global.__worker_appendTaskEvent(resolvedTaskId, event, message);
                global.__worker_logTaskEvent(resolvedTaskId, event, message);
              },
              currentDepth: 0
            });
          }
          var subtaskId = global.__worker_taskManager.submit(mergedArgs.goal, mergedArgs, {
            deadlineMs: timeout,
            metadata: postData.metadata || {}
          });
          global.__worker_tasks[taskId] = {
            taskId: taskId, subtaskId: subtaskId, status: "queued", goal: mergedArgs.goal,
            args: mergedArgs, createdAt: now, startedAt: __, completedAt: __,
            events: [], metadata: postData.metadata || {}
          };
          global.__worker_subtaskToTaskId[subtaskId] = taskId;
          global.__worker_subtaskShortToTaskId[subtaskId.substring(0, 8)] = taskId;
          global.__worker_logTaskEvent(taskId, "info", "[subtask:" + subtaskId.substring(0, 8) + "] Task accepted by worker");
          global.__worker_taskManager.start(subtaskId);
          global.__worker_tasks[taskId].status = "running";
          global.__worker_tasks[taskId].startedAt = new Date().getTime();
          return { taskId: taskId, createdAt: now };
        })();
      } finally {
        request = _request;
      }

      var task = global.__worker_tasks[submission.taskId];
      var response = {
        task: {
          id: submission.taskId,
          contextId: isString(postData.contextId) ? postData.contextId : submission.taskId,
          status: {
            state: "TASK_STATE_WORKING",
            timestamp: new Date(task.startedAt || task.createdAt).toISOString()
          }
        }
      };
      return ow.server.httpd.reply(stringify(response, __, ""), 202, ow.server.httpd.mimes.JSON);
    } catch(e) {
      logErr(e);
      return ow.server.httpd.reply(stringify({ error: String(e) }, __, ""), 500, ow.server.httpd.mimes.JSON);
    }
  ((error    )): true

- (httpdService): "${onport:-8888}"
  ((uri       )): /tasks
  ((execPre   )): *authCheck
  ((execURI   )): | #js
    try {
      var toState = function(status) {
        if (status === "completed") return "TASK_STATE_COMPLETED";
        if (status === "failed") return "TASK_STATE_FAILED";
        if (status === "cancelled") return "TASK_STATE_CANCELED";
        return "TASK_STATE_WORKING";
      };
      var asTask = function(task) {
        return {
          id: task.taskId,
          contextId: isMap(task.metadata) && isString(task.metadata.a2aContextId) ? task.metadata.a2aContextId : task.taskId,
          status: {
            state: toState(task.status),
            timestamp: new Date((task.completedAt || task.startedAt || task.createdAt)).toISOString()
          }
        };
      };

      var taskId = __;
      if (isMap(request.params)) {
        if (isString(request.params.id)) taskId = request.params.id;
        if (isString(request.params.taskId)) taskId = request.params.taskId;
      }
      if (isString(taskId) && taskId.length > 0) {
        var task = global.__worker_tasks[taskId];
        if (isUnDef(task)) return ow.server.httpd.reply(stringify({ error: "Task not found" }, __, ""), 404, ow.server.httpd.mimes.JSON);
        try {
          var subtaskStatus = global.__worker_taskManager.status(task.subtaskId);
          task.status = subtaskStatus.status;
          if (isDef(subtaskStatus.completedAt)) task.completedAt = subtaskStatus.completedAt;
        } catch(ignoreStatusErr) {}
        return ow.server.httpd.reply(stringify({ task: asTask(task) }, __, ""), __, ow.server.httpd.mimes.JSON);
      }

      var tasks = Object.keys(global.__worker_tasks).map(function(id) {
        var task = global.__worker_tasks[id];
        try {
          var subtaskStatus = global.__worker_taskManager.status(task.subtaskId);
          task.status = subtaskStatus.status;
          if (isDef(subtaskStatus.completedAt)) task.completedAt = subtaskStatus.completedAt;
        } catch(ignoreStatusErr) {}
        return asTask(task);
      });
      return ow.server.httpd.reply(stringify({ tasks: tasks }, __, ""), __, ow.server.httpd.mimes.JSON);
    } catch(e) {
      logErr(e);
      return ow.server.httpd.reply(stringify({ error: String(e) }, __, ""), 500, ow.server.httpd.mimes.JSON);
    }
  ((error    )): true

- (httpdService): "${onport:-8888}"
  ((uri       )): /tasks:cancel
  ((execPre   )): *authCheck
  ((execURI   )): | #js
    try {
      var postData;
      try { postData = jsonParse(request.files.postData); } catch(jsonErr) {
        postData = isMap(request.params) ? request.params : {};
      }
      var taskId = isString(postData.id) ? postData.id : postData.taskId;
      if (!isString(taskId) || taskId.length === 0) {
        return ow.server.httpd.reply(stringify({ error: "Missing required field: id" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var task = global.__worker_tasks[taskId];
      if (isUnDef(task)) return ow.server.httpd.reply(stringify({ error: "Task not found" }, __, ""), 404, ow.server.httpd.mimes.JSON);
      var reason = postData.reason || "Cancelled via A2A REST";
      try {
        global.__worker_taskManager.cancel(task.subtaskId, reason);
        task.status = "cancelled";
        task.completedAt = new Date().getTime();
      } catch(ignoreCancelErr) {}
      return ow.server.httpd.reply(stringify({ task: { id: taskId, status: { state: "TASK_STATE_CANCELED", timestamp: new Date(task.completedAt).toISOString() } } }, __, ""), __, ow.server.httpd.mimes.JSON);
    } catch(e) {
      logErr(e);
      return ow.server.httpd.reply(stringify({ error: String(e) }, __, ""), 500, ow.server.httpd.mimes.JSON);
    }
  ((error    )): true

- (httpdService): "${onport:-8888}"
  ((uri       )): /extendedAgentCard
  ((execPre   )): *authCheck
  ((execURI   )): | #js
    var wargs = global.__worker_args;
    var card = {
      protocolVersion: "0.3.0",
      name: isString(wargs.workername) ? wargs.workername : "mini-a-worker",
      description: isString(wargs.workerdesc) ? wargs.workerdesc : "Mini-A worker API",
      version: "1.0.0",
      capabilities: {
        streaming: false,
        pushNotifications: false,
        stateTransitionHistory: true
      },
      interfaces: {
        a2aHttpJsonRest: {
          messageSend: "/message:send",
          tasks: "/tasks",
          cancel: "/tasks:cancel"
        }
      }
    };
    return ow.server.httpd.reply(stringify(card, __, ""), __, ow.server.httpd.mimes.JSON);
  ((error    )): true

- (httpdService): "${onport:-8888}"
  ((uri       )): /status
  ((execPre   )): *authCheck
  ((execURI   )): | #js
    try {
      var postData;
      try { postData = jsonParse(request.files.postData); } catch(jsonErr) {
        return ow.server.httpd.reply(stringify({ error: "Invalid JSON in request body" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var taskId = postData.taskId;
      if (!isString(taskId)) {
        return ow.server.httpd.reply(stringify({ error: "Missing required field: taskId" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var task = global.__worker_tasks[taskId];
      if (isUnDef(task)) {
        return ow.server.httpd.reply(stringify({ error: "Task not found" }, __, ""), 404, ow.server.httpd.mimes.JSON);
      }
      try {
        var subtaskStatus = global.__worker_taskManager.status(task.subtaskId);
        task.status = subtaskStatus.status;
        if (isDef(subtaskStatus.completedAt)) { task.completedAt = subtaskStatus.completedAt; }
      } catch(statusErr) {}
      var response = {
        taskId: taskId, status: task.status, startedAt: task.startedAt,
        elapsed: task.startedAt ? (new Date().getTime() - task.startedAt) : 0,
        events: task.events || []
      };
      if (task.status === "running" && isDef(task.args) && isDef(task.args.maxsteps)) {
        response.progress = { maxSteps: task.args.maxsteps };
      }
      return ow.server.httpd.reply(stringify(response, __, ""), __, ow.server.httpd.mimes.JSON);
    } catch(e) {
      logErr(e);
      return ow.server.httpd.reply(stringify({ error: String(e) }, __, ""), 500, ow.server.httpd.mimes.JSON);
    }
  ((error    )): true

- (httpdService): "${onport:-8888}"
  ((uri       )): /result
  ((execPre   )): *authCheck
  ((execURI   )): | #js
    try {
      var postData;
      try { postData = jsonParse(request.files.postData); } catch(jsonErr) {
        return ow.server.httpd.reply(stringify({ error: "Invalid JSON in request body" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var taskId = postData.taskId;
      if (!isString(taskId)) {
        return ow.server.httpd.reply(stringify({ error: "Missing required field: taskId" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var task = global.__worker_tasks[taskId];
      if (isUnDef(task)) {
        return ow.server.httpd.reply(stringify({ error: "Task not found" }, __, ""), 404, ow.server.httpd.mimes.JSON);
      }
      try {
        var subtaskResult = global.__worker_taskManager.result(task.subtaskId);
        var subtaskStatus = global.__worker_taskManager.status(task.subtaskId);
        task.status = subtaskStatus.status;
        if (isDef(subtaskStatus.completedAt)) { task.completedAt = subtaskStatus.completedAt; }
        var response = {
          taskId: taskId, status: task.status,
          result: {
            goal: task.goal, answer: subtaskResult.answer, format: task.args.format || "md",
            metrics: subtaskResult.metrics || {}, state: subtaskResult.state || {},
            error: subtaskResult.error
          },
          completedAt: task.completedAt,
          duration: task.completedAt && task.startedAt ? (task.completedAt - task.startedAt) : 0
        };
        return ow.server.httpd.reply(stringify(response, __, ""), __, ow.server.httpd.mimes.JSON);
      } catch(resultErr) {
        var errMsg = isDef(resultErr) && isString(resultErr.message) ? resultErr.message : String(resultErr);
        if (errMsg.indexOf("not in terminal state") >= 0) {
          return ow.server.httpd.reply(stringify({ error: "Task is not yet complete" }, __, ""), 400, ow.server.httpd.mimes.JSON);
        }
        throw resultErr;
      }
    } catch(e) {
      logErr(e);
      return ow.server.httpd.reply(stringify({ error: String(e) }, __, ""), 500, ow.server.httpd.mimes.JSON);
    }
  ((error    )): true

- (httpdService): "${onport:-8888}"
  ((uri       )): /cancel
  ((execPre   )): *authCheck
  ((execURI   )): | #js
    try {
      var postData;
      try { postData = jsonParse(request.files.postData); } catch(jsonErr) {
        return ow.server.httpd.reply(stringify({ error: "Invalid JSON in request body" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var taskId = postData.taskId;
      if (!isString(taskId)) {
        return ow.server.httpd.reply(stringify({ error: "Missing required field: taskId" }, __, ""), 400, ow.server.httpd.mimes.JSON);
      }
      var task = global.__worker_tasks[taskId];
      if (isUnDef(task)) {
        return ow.server.httpd.reply(stringify({ error: "Task not found" }, __, ""), 404, ow.server.httpd.mimes.JSON);
      }
      var reason = postData.reason || "Cancelled by user";
      try {
        global.__worker_taskManager.cancel(task.subtaskId, reason);
        task.status = "cancelled";
        task.completedAt = new Date().getTime();
      } catch(cancelErr) {}
      return ow.server.httpd.reply(stringify({ taskId: taskId, status: task.status }, __, ""), __, ow.server.httpd.mimes.JSON);
    } catch(e) {
      logErr(e);
      return ow.server.httpd.reply(stringify({ error: String(e) }, __, ""), 500, ow.server.httpd.mimes.JSON);
    }
  ((error    )): true

- Cleanup Loop
- Register With Parents

ojob:
  opacks      :
  - openaf     : 20250915
  - oJob-common: 20250914
  - mini-a
  catch       : logErr(exception); $err(exception, __, __, job.exec)
  logToConsole: false
  argsFromEnvs: true
  daemon      : true
  unique      :
    pidFile     : .mini-a-worker.pid
    killPrevious: true
  loadLibs    :
  - mini-a.js
  - mini-a-subtask.js

jobs:
# ----------
- name : Init
  exec : | #js
    // Check environment
    if (isUnDef(getEnv("OAF_MODEL"))) {
      throw "OAF_MODEL environment variable not set. Export OAF_MODEL before starting the worker."
    }

    // Set defaults
    args.onport = _$(args.onport, "args.onport").toNumber().isNumber().default(8080)
    args.apitoken = _$(args.apitoken, "args.apitoken").isString().default(__)
    args.apiallow = _$(args.apiallow, "args.apiallow").isString().default(__)
    args.maxconcurrent = _$(args.maxconcurrent, "args.maxconcurrent").toNumber().isNumber().default(4)
    args.defaulttimeout = _$(args.defaulttimeout, "args.defaulttimeout").toNumber().isNumber().default(300000)
    args.maxtimeout = _$(args.maxtimeout, "args.maxtimeout").toNumber().isNumber().default(600000)
    args.taskretention = _$(args.taskretention, "args.taskretention").toNumber().isNumber().default(3600)
    args.workername = _$(args.workername, "args.workername").isString().default("mini-a-worker")
    args.workerdesc = _$(args.workerdesc, "args.workerdesc").isString().default("Mini-A worker API")
    args.delegationmaxretries = _$(args.delegationmaxretries, "args.delegationmaxretries").toNumber().isNumber().default(2)
    args.delegationmaxdepth = _$(args.delegationmaxdepth, "args.delegationmaxdepth").toNumber().isNumber().default(3)
    args.workerregurl = _$(args.workerregurl, "args.workerregurl").isString().default(__)
    args.workerregtoken = _$(args.workerregtoken, "args.workerregtoken").isString().default(__)
    args.workerreginterval = _$(args.workerreginterval, "args.workerreginterval").toNumber().isNumber().default(30000)

    // Validate
    if (isUnDef(args.apitoken)) {
      logWarn("No API token configured. Authentication is DISABLED. Set apitoken= parameter for production use.")
    }

    // Parse IP allowlist
    global.__worker_ipallow = []
    if (isString(args.apiallow) && args.apiallow.length > 0) {
      global.__worker_ipallow = args.apiallow.split(",").map(function(ip) { return ip.trim() }).filter(function(ip) { return ip.length > 0 })
      log("IP allowlist configured: " + global.__worker_ipallow.join(", "))
    }

    // Initialize global state
    global.__worker_args = args
    global.__worker_tasks = {}
    global.__worker_taskManager = __
    global.__worker_startTime = java.lang.System.currentTimeMillis()
    global.__worker_subtaskToTaskId = {}
    global.__worker_subtaskShortToTaskId = {}
    global.__worker_regTargets = []
    global.__worker_selfUrl = __
    global.__worker_regInterval = __

    global.__worker_appendTaskEvent = function(taskId, event, message) {
      if (!isString(taskId) || isUnDef(global.__worker_tasks[taskId])) return
      if (isUnDef(global.__worker_tasks[taskId].events)) global.__worker_tasks[taskId].events = []
      global.__worker_tasks[taskId].events.push({
        event: isString(event) ? event : "info",
        message: isString(message) ? message : String(message),
        ts: new Date().getTime()
      })
    }

    global.__worker_logTaskEvent = function(taskId, event, message) {
      var eventName = isString(event) && event.length > 0 ? event : "info"
      var msgText = isString(message) ? message : String(message)
      var normalized = msgText.replace(/\n/g, "â†µ")
      var prefix = "[mini-a-worker]"
      if (isString(taskId) && taskId.length > 0) {
        prefix += "[task:" + taskId.substring(0, 8) + "]"
      }
      log(prefix + "[" + eventName + "] " + normalized)
    }

    global.__worker_resolveTaskIdFromMessage = function(message) {
      if (!isString(message)) return __
      var match = message.match(/^\[subtask:([^\]]+)\]/)
      if (!isArray(match) || match.length < 2) return __
      var shortId = String(match[1] || "").trim()
      if (shortId.length === 0) return __
      if (isString(global.__worker_subtaskShortToTaskId[shortId])) return global.__worker_subtaskShortToTaskId[shortId]
      return __
    }

    log("Mini-A Worker API starting on port " + args.onport)
    log("Max concurrent tasks: " + args.maxconcurrent)
    log("Default timeout: " + args.defaulttimeout + "ms")
    log("Task retention: " + args.taskretention + "s")

# ---------------
- name : Cleanup Loop
  deps : Init
  exec : | #js
    var retention = global.__worker_args.taskretention * 1000

    // Cleanup old completed tasks periodically
    setInterval(function() {
      try {
        var now = new Date().getTime()
        var taskIds = Object.keys(global.__worker_tasks)

        taskIds.forEach(function(taskId) {
          var task = global.__worker_tasks[taskId]
          if (isDef(task.completedAt)) {
            var age = now - task.completedAt
            if (age > retention) {
              try {
                global.__worker_taskManager.cleanup(task.subtaskId)
              } catch(ignoreCleanup) {}
              if (isString(task.subtaskId) && task.subtaskId.length > 0) {
                delete global.__worker_subtaskToTaskId[task.subtaskId]
                delete global.__worker_subtaskShortToTaskId[task.subtaskId.substring(0, 8)]
              }
              delete global.__worker_tasks[taskId]
              log("Cleaned up task " + taskId + " (age: " + Math.round(age / 1000) + "s)")
            }
          }
        })
      } catch(cleanupErr) {
        logErr(cleanupErr)
      }
    }, 60000) // Run every minute

# ---------------
- name : Register With Parents
  deps : Init
  exec : | #js
    var regUrls = args.workerregurl
    if (!isString(regUrls) || regUrls.trim().length === 0) return

    var targets = regUrls.split(",").map(function(u) { return String(u || "").trim() }).filter(function(u) { return u.length > 0 })
    if (targets.length === 0) return

    ow.loadNet()
    var myHost = ow.net.getHostAddress()
    if (!isString(myHost) || myHost.trim().length === 0) myHost = ow.net.getHostName()
    var myUrl = "http://" + myHost + ":" + args.onport

    global.__worker_selfUrl = myUrl
    global.__worker_regTargets = targets

    var headers = {}
    if (isString(args.workerregtoken) && args.workerregtoken.length > 0) {
      headers.Authorization = "Bearer " + args.workerregtoken
    }

    var _register = function(targetUrl) {
      var baseUrl = String(targetUrl || "").replace(/\/+$/, "")
      try {
        var resp = $rest({ requestHeaders: headers }).post(baseUrl + "/worker-register", { workerUrl: myUrl })
        if (isMap(resp) && resp.status === "ok") {
          log("[worker-reg] Registered with " + baseUrl + " as " + myUrl)
          return true
        }
        logWarn("[worker-reg] Registration response from " + baseUrl + ": " + stringify(resp, __, ""))
        return false
      } catch(e) {
        logWarn("[worker-reg] Failed to register with " + baseUrl + ": " + e)
        return false
      }
    }

    targets.forEach(_register)

    if (isUnDef(args.workerreginterval) || args.workerreginterval <= 0) args.workerreginterval = 30000
    global.__worker_regInterval = setInterval(function() {
      targets.forEach(_register)
    }, args.workerreginterval)

    log("[worker-reg] Heartbeat interval: " + args.workerreginterval + "ms to " + targets.length + " target(s)")

# ---------------
- name : Deregister From Parents
  type : shutdown
  exec : | #js
    if (isDef(global.__worker_regInterval)) {
      clearInterval(global.__worker_regInterval)
      global.__worker_regInterval = __
    }

    var targets = global.__worker_regTargets
    var myUrl = global.__worker_selfUrl
    if (!isArray(targets) || targets.length === 0 || !isString(myUrl) || myUrl.length === 0) return

    var headers = {}
    if (isDef(global.__worker_args) && isString(global.__worker_args.workerregtoken) && global.__worker_args.workerregtoken.length > 0) {
      headers.Authorization = "Bearer " + global.__worker_args.workerregtoken
    }

    targets.forEach(function(targetUrl) {
      var baseUrl = String(targetUrl || "").replace(/\/+$/, "")
      try {
        var resp = $rest({ requestHeaders: headers }).post(baseUrl + "/worker-deregister", { workerUrl: myUrl })
        if (isMap(resp) && resp.status === "ok") {
          log("[worker-reg] Deregistered from " + baseUrl)
        } else {
          logWarn("[worker-reg] Deregister response from " + baseUrl + ": " + stringify(resp, __, ""))
        }
      } catch(e) {
        logWarn("[worker-reg] Failed to deregister from " + baseUrl + ": " + e)
      }
    })
