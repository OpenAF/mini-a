# Author: Nuno Aguiar
help:
  text   : Mini-A web interface to interact with the Mini-A agent via HTTP. 
  expects: 
  - name     : onport
    desc     : Port to run the HTTP server on
    example  : "8888"
    mandatory: false
  - name     : showExecs
    desc     : Show executed commands in the interaction
    example  : "false"
    mandatory: false
  - name     : logPromptHeaders
    desc     : Log prompt headers to console (for debugging)
    example  : "origin,referer"
    mandatory: false

include:
- oJobHTTPd.yaml

todo:
- Init
- Periodic cleanup of old sessions
- (httpdStart     ): "${onport:-8888}"
  ((mapLibs      )): true
- (httpdHealthz   ): "${onport:-8888}"
- (httpdMetrics   ): "${onport:-8888}"
- (httpdFileBrowse): "${onport:-8888}"
  ((uri          )): /
  ((path         )): public
  ((browse       )): false
  ((default      )): index.md

- (httpdService   ): "${onport:-8888}"
  ((uri          )): /ping
  ((execURI      )): | #js
    return ow.server.httpd.reply({ status: "ok" })

- (httpdService   ): "${onport:-8888}"
  ((uri          )): /clear
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)
      if (isDef(global.__res[ postData.uuid ])) {
        delete global.__res[ postData.uuid ]
      }
      if (isDef(global.__conversations[ postData.uuid ])) {
        delete global.__conversations[ postData.uuid ]
      }
      if (isDef(global.__lastActivity[ postData.uuid ])) {
        delete global.__lastActivity[ postData.uuid ]
      }
      return ow.server.httpd.reply({ status: "cleared" })
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

- (httpdService   ): "${onport:-8888}"
  ((uri          )): /prompt
  ((execURI      )): | #js
    var _res = {}
    try {
      // Parse POST data
      var postData = jsonParse(request.files.postData)
      // Validate UUID or generate a new one
      if (isDef(postData.uuid)) {
        _res.uuid = postData.uuid
      } else {
        _res.uuid = genUUID()
      }

      // Initialize response storage
      if (isUnDef(global.__res[_res.uuid])) {
        global.__res[ _res.uuid ] = [ ]
        global.__conversations[ _res.uuid ] = __
        global.__lastActivity[ _res.uuid ] = Date.now()
      } else {
        global.__lastActivity[ _res.uuid ] = Date.now()
      }

      // Prompt header logging
      if (global.__logPromptHeaders.length > 0) {
        global.__logPromptHeaders.forEach( h => {
          if (isDef(request.header[h])) {
            log("[" + _res.uuid + "] Prompt header " + h + ": " + request.header[h])
          }
        })
      }

      // Start Mini-A interaction in a non-blocking way
      $doV(() => {
        try {
          var uuid = _res.uuid, lma
          if (isUnDef(global.__conversations[ uuid ])) {
            lma = new MiniA()
            lma.init(global.maArgs)
            lma.setInteractionFn( (e, m) => {
                var _e = ""
                switch(e) {
                case "user"     : _e = "ğŸ‘¤"; break
                case "exec"     : _e = "âš™ï¸"; break
                case "shell"    : _e = "ğŸ–¥ï¸"; break
                case "think"    : _e = "ğŸ’¡"; break
                case "final"    : _e = "ğŸ"; break
                case "input"    : _e = "â¡ï¸"; break
                case "output"   : _e = "â¬…ï¸"; break
                case "thought"  : _e = "ğŸ’­"; break
                case "think"    : _e = "ğŸ’¡"; break
                case "size"     : _e = "ğŸ“"; break
                case "rate"     : _e = "â³"; break
                case "mcp"      : _e = "ğŸ¤–"; break
                case "done"     : _e = "âœ…"; break
                case "error"    : _e = "âŒ"; break
                case "libs"     : _e = "ğŸ“š"; break
                case "info"     : _e = "â„¹ï¸"; break
                case "load"     : _e = "ğŸ“‚"; break
                case "mcp"      : _e = "ğŸ¤–"; break
                case "warn"     : _e = "âš ï¸"; break
                case "stop"     : _e = "ğŸ›‘"; break
                case "error"    : _e = "â—"; break
                case "summarize": _e = "ğŸ“"; break
                default         : _e = e
                }
                
                global.__res[uuid].push({ event: _e, message: m })
                log("[" + uuid + "] " + _e + " " + m)
            } )
            global.__conversations[ uuid ] = lma
          } else {
            lma = global.__conversations[ uuid ]
          }

          var _rma = lma.start(merge(global.maArgs, {
            goal        : postData.prompt,
            raw         : true
          }))

          global.__res[uuid].push( { event: "final", message: _rma } )
          log("[" + uuid + "] " + _rma)
        } catch(e) {
          logErr(e)
          $err(e)
        }
      })
    } catch(ee) {
      logErr(ee)
      $err(ee)
    }

    return ow.server.httpd.reply(_res)

- (httpdService   ): "${onport:-8888}"
  ((uri          )): /result
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)

      if (isDef(postData.request) && postData.request == "stop") {
        global.__conversations[ postData.uuid ].state = "stop"
      }
      var _res = { content: "", status: "processing", history: [] }
      if (isDef(global.__res[ postData.uuid ])) {
        // Update last activity
        global.__lastActivity[ postData.uuid ] = Date.now()

        // Append all messages to content
        var _history = []
        for (var i = 0; i < global.__res[ postData.uuid ].length; i++) {
          var r = global.__res[ postData.uuid ][i]
          if (isDef(r.event)) {
            var _h = { event: r.event }
            if (isDef(r.message)) _h.message = r.message
            _history.push(_h)
          }
          if (r.event == "final") {
            if (i == global.__res[ postData.uuid ].length - 1) _res.status = "finished"
            _res.content += "\n" + r.message + "\n"
            //delete global.__res[ postData.uuid ]
            //break
          } else {
            if (r.event == "ğŸ‘¤" || (r.event == "âš™ï¸" && global.__showExecs) || (r.event == "ğŸ–¥ï¸" && global.__showExecs) || r.event == "ğŸ’¡" || r.event == "ğŸ’­" || r.event == "ğŸ¤–" || r.event == "ğŸ“") {
              if (r.event == "ğŸ‘¤") {
                _res.content += "<div style=\"text-align: right;\"><i><div style=\"display: inline-block; text-align: left;\">" + r.message.replace(/\n/g, "<br>") + "</div> " + r.event + "</i>\n<br><br></div>"
              } else {
                _res.content += r.event + " <i>" + r.message.replace(/\n/g, "<br>") + "</i>\n"
              }
            }
          }
        }
        _res.history = _history
      }

      return ow.server.httpd.reply(_res)
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

- (httpdService   ): "${onport:-8888}"
  ((uri          )): /load-history
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)

      if (isUnDef(postData.uuid)) {
        return ow.server.httpd.reply({ error: "uuid is required" })
      }

      if (isUnDef(postData.history) || !Array.isArray(postData.history)) {
        return ow.server.httpd.reply({ error: "history must be an array" })
      }

      var sanitized = []
      for (var i = 0; i < postData.history.length; i++) {
        var item = postData.history[i]
        if (isUnDef(item) || isUnDef(item.event)) continue
        var entry = { event: item.event }
        if (isDef(item.message)) entry.message = item.message
        sanitized.push(entry)
      }

      global.__res[ postData.uuid ] = sanitized
      delete global.__conversations[ postData.uuid ]
      global.__lastActivity[ postData.uuid ] = Date.now()

      return ow.server.httpd.reply({ status: "loaded", uuid: postData.uuid, entries: sanitized.length })
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

ojob:
  opacks      :
  - openaf: 20250915
  - oJob-common
  - mini-a
  catch       : printErrnl("[" + job.name + "] "); $err(exception, __, __, job.exec)
  logToConsole: true   # to change when finished
  daemon      : true
  argsFromEnvs: true
  loadLibs    :
  - mini-a.js
  channels    :
    create:
    - name: conversations
    - name: lastActivity
    - name: results

jobs:
# -----------
- name : Init
  check:
    in:
      showExecs       : toBoolean().isBoolean().default(false)
      logPromptHeaders: isString().default("")
      maxcontent      : toNumber().isNumber().default(200000)
  exec : | #js
    global.__res = {}
    global.__conversations = {}
    global.__lastActivity = { }
    global.__showExecs = args.showExecs
    global.__logPromptHeaders = args.logPromptHeaders.split(",").map(h => h.trim().toLowerCase()).filter(h => h.length > 0)
    args.__format = "md"
    global.maArgs = merge(args, {})
    global.ma = new MiniA()
    global.ma.init( global.maArgs )

# ---------------------------------------
- name : Periodic cleanup of old sessions
  type : periodic
  typeArgs:
    interval: 300000  # every 5 minutes
  exec : | #js
    var now = Date.now()
    var toDelete = []
    for (var uuid in global.__lastActivity) {
      // If no activity for more than 5 minutes, delete session
      if (now - global.__lastActivity[ uuid ] > 300000) {
        toDelete.push(uuid)
      }
    }
    for (var i = 0; i < toDelete.length; i++) {
      var uuid = toDelete[i]
      delete global.__lastActivity[ uuid ]
      delete global.__res[ uuid ]
      delete global.__conversations[ uuid ]
      log("Cleaned up session " + uuid)
    }