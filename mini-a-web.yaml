# Author: Nuno Aguiar
help:
  text   : Mini-A web interface to interact with the Mini-A agent via HTTP. 
  expects: 
  - name     : onport
    desc     : Port to run the HTTP server on
    example  : "8888"
    mandatory: false
  - name     : showexecs
    desc     : Show executed commands in the interaction
    example  : "false"
    mandatory: false
    options  : ["true", "false"]
  - name     : logpromptheaders
    desc     : Log prompt headers to console (for debugging)
    example  : "origin,referer"
    mandatory: false
  - name     : usehistory
    desc     : "Boolean to enable/disable history (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : useattach
    desc     : "Boolean to enable/disable file attachments (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : historypath
    desc     : "Path to store history files (default: .)"
    example  : "."
    mandatory: false
  - name     : historyretention
    desc     : "History retention period in seconds (default: 600)"
    example  : "600"
    mandatory: false
  - name     : historykeep
    desc     : "Boolean to keep history files (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : maxcontext
    desc     : "Maximum conversation tokens before Mini-A summarizes context (default: 200000)"
    example  : "200000"
    mandatory: false
  - name     : useplanning
    desc     : "Boolean to enable/disable task planning (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]

include:
- oJobHTTPd.yaml

todo:
- Init
- Periodic cleanup of old sessions
- (httpdStart     ): "${onport:-8888}"
  ((mapLibs      )): true
- (httpdHealthz   ): "${onport:-8888}"
- (httpdMetrics   ): "${onport:-8888}"
- Static content
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /ping
  ((execURI      )): | #js
    return ow.server.httpd.reply({ status: "ok" })

# Info about the server
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /info
  ((execURI      )): | #js
    try {
      var _res = { status: "ok", usehistory: global.__usehistory, useattach: global.__useattach, historyretention: args.historyretention, showexecs: global.__showexecs }
      return ow.server.httpd.reply(_res)
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Clear a session
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /clear
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)
      // postData.force - to be used from the history pane to delete a specific session
      // __useHistory - if no history is being used, always clear
      if (!global.__usehistory || postData.force) {
        log("Clearing session " + postData.uuid)
        if (isDef(global.__res[ postData.uuid ])) {
          delete global.__res[ postData.uuid ]
        }
        if (isDef(global.__conversations[ postData.uuid ])) {
          delete global.__conversations[ postData.uuid ]
        }
        if (isDef(global.__lastActivity[ postData.uuid ])) {
          delete global.__lastActivity[ postData.uuid ]
        }
        if (isDef(global.__planState) && isDef(global.__planState[ postData.uuid ])) {
          delete global.__planState[ postData.uuid ]
        }
        if (global.__usehistory && !global.__historykeep) {
          log("Deleting history file for session " + postData.uuid)
          var _hfile = global.__historypath + "/c-" + postData.uuid + ".json"
          if (io.fileExists(_hfile)) {
            io.rm(_hfile)
          }
        }
      }
      return ow.server.httpd.reply({ status: "cleared" })
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Submit a prompt
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /prompt
  ((execURI      )): | #js
    var _res = { error: "check server logs" }
    try {
      
      // Parse POST data
      var postData = jsonParse(request.files.postData)
      // Validate UUID or generate a new one
      if (isDef(postData.uuid)) {
        _res.uuid = postData.uuid
      } else {
        _res.uuid = genUUID()
      }
      
      // Initialize response storage
      if (isUnDef(global.__res[_res.uuid])) {
        global.__res[ _res.uuid ] = [ ]
        global.__conversations[ _res.uuid ] = __
        global.__lastActivity[ _res.uuid ] = Date.now()
      } else {
        global.__lastActivity[ _res.uuid ] = Date.now()
      }
      
      // Prompt header logging
      if (global.__logpromptheaders.length > 0) {
        global.__logpromptheaders.forEach( h => {
          if (isDef(request.header[h])) {
            log("[" + _res.uuid + "] Prompt header " + h + ": " + request.header[h])
          }
        })
      }
      // Start Mini-A interaction in a non-blocking way
      $doV(() => {
        var uuid = _res.uuid, lma
        if (isDef(global.__planState) && isDef(global.__planState[ uuid ])) {
          delete global.__planState[ uuid ]
        }

        // If history is enabled, set the history file
        var _hfile = global.__usehistory ? global.__historypath + "/c-" + uuid + ".json" : __

        // If conversation does not exist, create it
        if (isUnDef(global.__conversations[ uuid ])) {
          // If history file does not exist but we have history in memory, rebuild it
          if (global.__usehistory && !io.fileExists(_hfile) && isDef(global.__res[ uuid ]) && global.__res[ uuid ].length > 0) {
            // Try rebuilding
            var _data = []
            for (var i = 0; i < global.__res[ uuid ].length; i++) {
              var r = global.__res[ uuid ][i]
              if (r.event == "👤") {
                _data.push( { role: "user", content: r.message } )
              } else if (r.event == "🤖" || r.event == "⬅️") {
                _data.push( { role: "assistant", content: r.message } )
              } else if (r.event == "⚙️" || r.event == "🖥️") {
                _data.push( { role: "system", content: r.message } )
              }
            }
            if (_data.length > 0) {
              io.writeFileJSON(_hfile, { u: new Date(), c: _data }, "")
              log("[" + uuid + "] Rebuilt history file " + _hfile)
            }
          }
      
          // Initialize MiniA
          lma = new MiniA()
          lma.init(merge(global.maArgs, {
            conversation: global._mini_a_web_loadFile(_hfile)
          }))
          lma.setInteractionFn( (e, m) => {
            try {
              var _e = ""
              switch(e) {
              case "user"     : _e = "👤"; break
              case "exec"     : _e = "⚙️"; break
              case "shell"    : _e = "🖥️"; break
              case "think"    : _e = "💡"; break
              case "final"    : _e = "🏁"; break
              case "input"    : _e = "➡️"; break
              case "output"   : _e = "⬅️"; break
              case "thought"  : _e = "💭"; break
              case "think"    : _e = "💡"; break
              case "size"     : _e = "📏"; break
              case "rate"     : _e = "⏳"; break
              case "mcp"      : _e = "🤖"; break
              case "plan"     : _e = "🗺️"; break
              case "done"     : _e = "✅"; break
              case "error"    : _e = "❌"; break
              case "libs"     : _e = "📚"; break
              case "info"     : _e = "ℹ️"; break
              case "load"     : _e = "📂"; break
              case "mcp"      : _e = "🤖"; break
              case "warn"     : _e = "⚠️"; break
              case "stop"     : _e = "🛑"; break
              case "error"    : _e = "❗"; break
              case "summarize": _e = "🌀"; break
              default         : _e = e
              }

              if (_e == "🗺️") {
                try {
                  if (isFunction(lma._normalizePlanItems)) {
                    var planItems = lma._normalizePlanItems(isObject(lma._agentState) ? lma._agentState.plan : __)
                    if (isArray(planItems) && planItems.length > 0) {
                      var statusIcons = {
                        pending     : { icon: "⏳", label: "pending" },
                        todo        : { icon: "⏳", label: "to do" },
                        not_started : { icon: "⏳", label: "not started" },
                        ready       : { icon: "⏳", label: "ready" },
                        in_progress : { icon: "⚙️", label: "in progress" },
                        progressing : { icon: "⚙️", label: "in progress" },
                        working     : { icon: "⚙️", label: "working" },
                        running     : { icon: "⚙️", label: "running" },
                        active      : { icon: "⚙️", label: "active" },
                        done        : { icon: "✅", label: "done" },
                        complete    : { icon: "✅", label: "complete" },
                        completed   : { icon: "✅", label: "completed" },
                        finished    : { icon: "✅", label: "finished" },
                        success     : { icon: "✅", label: "success" },
                        blocked     : { icon: "🛑", label: "blocked" },
                        stuck       : { icon: "🛑", label: "stuck" },
                        paused      : { icon: "⏸️", label: "paused" },
                        waiting     : { icon: "⏳", label: "waiting" },
                        failed      : { icon: "❌", label: "failed" },
                        cancelled   : { icon: "🚫", label: "cancelled" },
                        canceled    : { icon: "🚫", label: "cancelled" }
                      }
                      var doneStatuses = {
                        done: true,
                        complete: true,
                        completed: true,
                        finished: true,
                        success: true
                      }
                      var normalized = []
                      for (var i = 0; i < planItems.length; i++) {
                        var entry = planItems[i] || {}
                        var statusKey = (entry.status || entry.rawStatus || "").toString()
                        var statusInfo = statusIcons[statusKey] || { icon: "•", label: statusKey || "pending" }
                        var isDone = doneStatuses[statusKey] === true || statusInfo.icon == "✅"
                        normalized.push({
                          title   : entry.title || ("Step " + (i + 1)),
                          status  : statusKey,
                          icon    : statusInfo.icon,
                          label   : statusInfo.label,
                          done    : isDone === true,
                          rawStatus: entry.rawStatus
                        })
                      }
                      var completedCount = 0
                      normalized.forEach(item => { if (item.done === true) completedCount++ })
                      global.__planState[uuid] = {
                        items    : normalized,
                        total    : normalized.length,
                        completed: completedCount,
                        active   : normalized.length > 0,
                        updated  : Date.now()
                      }
                    } else {
                      if (isDef(global.__planState[uuid])) delete global.__planState[uuid]
                    }
                  }
                } catch(planErr) {
                  logErr(planErr)
                }
              //} else if (_e == "🏁" || _e == "✅" || _e == "❌") {
              } else if (_e == "🏁" || _e == "🛑") {
                if (isDef(global.__planState[uuid])) {
                  log(`[${uuid}] ${_e} Plan closed`)
                  delete global.__planState[uuid]
                }
              }
              global.__res[uuid].push({ event: _e, message: m })
              log("[" + uuid + "] " + _e + " " + m)
            } catch(eee) {
              $err(eee)
              logWarn(`[${uuid}] Plan closed`)
              delete global.__planState[uuid]
            }
          })
          global.__conversations[ uuid ] = lma
        } else {
          lma = global.__conversations[ uuid ]
        }

        var _rma = lma.start(merge(global.maArgs, {
          goal        : postData.prompt,
          raw         : true,
          conversation: global._mini_a_web_loadFile(_hfile)
        }))

        global.__res[uuid].push( { event: "final", message: (isObject(_rma) ? af.toSLON(_rma) : _rma) } )
        log("[" + uuid + "] " + (isObject(_rma) ? af.toSLON(_rma) : _rma))
      }).catch((eee) => {
        logErr(eee)
        $err(eee)
      })
    } catch(ee) {
      logErr(ee)
      $err(ee)
    }

    return ow.server.httpd.reply(_res)

# Get results of a prompt
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /result
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)

      if (isDef(postData.request) && postData.request == "stop") {
        global.__conversations[ postData.uuid ].state = "stop"
      }
      var _res = { content: "", status: "processing", history: [] }
      var __attachmentLangMap = {
        md: 'markdown', markdown: 'markdown', json: 'json', yaml: 'yaml', yml: 'yaml',
        csv: 'csv', tsv: 'tsv', xml: 'xml', html: 'html', htm: 'html', css: 'css', scss: 'scss', less: 'less',
        js: 'javascript', mjs: 'javascript', cjs: 'javascript', ts: 'typescript', jsx: 'jsx', tsx: 'tsx',
        py: 'python', rb: 'ruby', go: 'go', java: 'java', kt: 'kotlin', c: 'c', h: 'c', cpp: 'cpp', cc: 'cpp', hpp: 'cpp', cs: 'csharp',
        rs: 'rust', php: 'php', sh: 'bash', bash: 'bash', zsh: 'bash', fish: 'bash', sql: 'sql', toml: 'toml', ini: 'ini', cfg: 'ini', conf: 'ini', env: 'ini',
        properties: 'ini', gradle: 'groovy', dockerfile: 'dockerfile', makefile: 'makefile', cmake: 'cmake', r: 'r', lua: 'lua', swift: 'swift', scala: 'scala'
      }

      function __escapeHtml(str) {
        if (isUnDef(str)) return ''
        return ('' + str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;')
      }

      function __escapeAttr(str) {
        return __escapeHtml(str).replace(/[\r\n]+/g, ' ')
      }

      function __detectAttachmentLang(name) {
        if (isUnDef(name)) return 'text'
        var lowered = ('' + name).toLowerCase()
        if (lowered == 'dockerfile') return 'dockerfile'
        if (lowered.indexOf('makefile') == 0) return 'makefile'
        var parts = lowered.split('.')
        var ext = parts.length > 1 ? parts.pop() : ''
        if (isDef(__attachmentLangMap[ext])) return __attachmentLangMap[ext]
        return 'text'
      }

      function __formatUserMessage(message) {
        if (isUnDef(message)) return ''
        var text = '' + message
        var attachments = []
        text = text.replace(/```attachment\s+([^\n]+)\n([\s\S]*?)```/gm, function(_, name, content) {
          var cleanName = ('' + name).replace(/[\r\n]+/g, ' ').trim()
          var cleanContent = ('' + content).replace(/\r\n/g, '\n')
          attachments.push({ name: cleanName, content: cleanContent })
          return '§§ATTACHMENT_' + (attachments.length - 1) + '§§'
        })

        var html = __escapeHtml(text).replace(/\n/g, '<br>')
        for (var j = 0; j < attachments.length; j++) {
          var att = attachments[j]
          var placeholder = '§§ATTACHMENT_' + j + '§§'
          var safeName = att.name && att.name.length > 0 ? att.name : 'attachment.txt'
          var safeNameHtml = __escapeHtml(safeName)
          var attrName = __escapeAttr(safeName)
          var encoded = af.fromBytes2String(af.toBase64Bytes(att.content || ''))
          var language = __detectAttachmentLang(att.name)
          var button = '<button class="user-attachment" type="button" data-name="' + attrName + '" data-language="' + __escapeAttr(language) + '" data-content="' + __escapeAttr(encoded) + '">📎 ' + safeNameHtml + '</button>'
          html = html.replace(placeholder, button)
        }

        return html
      }
      if (isDef(global.__res[ postData.uuid ])) {
        // Update last activity
        global.__lastActivity[ postData.uuid ] = Date.now()
        var planState = isDef(global.__planState) ? global.__planState[ postData.uuid ] : __
        var hasActivePlan = isDef(planState) && isArray(planState.items) && planState.items.length > 0

        // Append all messages to content
        var _history = []
        for (var i = 0; i < global.__res[ postData.uuid ].length; i++) {
          var r = global.__res[ postData.uuid ][i]
          if (isDef(r.event)) {
            var _h = { event: r.event }
            if (isDef(r.message)) _h.message = r.message
            _history.push(_h)
          }
          if (r.event == "final") {
            if (i == global.__res[ postData.uuid ].length - 1) _res.status = "finished"
            _res.content += "\n" + r.message + "\n"
            //delete global.__res[ postData.uuid ]
            //break
          } else {
            // Exclude planning (🗺️) messages from the content log; plan panel remains driven by __planState
            if (r.event == "👤" || (r.event == "⚙️" && global.__showexecs) || (r.event == "🖥️" && global.__showexecs) || r.event == "💡" || r.event == "💭" || r.event == "🌀" || r.event == "🛑" || r.event == "⏳") {
              if (r.event == "👤") {
                _res.content += "<div style=\"text-align: right;\"><i><div style=\"display: inline-block; text-align: left;\">" + __formatUserMessage(r.message) + "</div> " + r.event + "</i>\n<br><br></div>"
              } else {
                _res.content += r.event + " <i><span style=\"color: var(--text); opacity: 0.60;\">" + r.message.replace(/\n/g, "<br>") + "</span></i>\n"
              }
            }
          }
        }
        _res.history = _history
        if (hasActivePlan) {
          _res.plan = {
            active   : true,
            items    : planState.items,
            total    : planState.total,
            completed: planState.completed,
            updated  : planState.updated
          }
        } else {
          _res.plan = { active: false, items: [], total: 0, completed: 0 }
        }
      }

      return ow.server.httpd.reply(_res)
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Load history for a session
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /load-history
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)

      if (isUnDef(postData.uuid)) {
        return ow.server.httpd.reply({ error: "uuid is required" })
      }

      if (isUnDef(postData.history) || !Array.isArray(postData.history)) {
        return ow.server.httpd.reply({ error: "history must be an array" })
      }

      // If already stored no need to load again
      if (isDef(global.__res[ postData.uuid ])) {
        logWarn("History for " + postData.uuid + " already loaded")
        return ow.server.httpd.reply({ status: "loaded", uuid: postData.uuid, entries: global.__res[ postData.uuid ].length })
      } else {
        logWarn("History for " + postData.uuid + " not found. Rebuilding from provided history with " + postData.history.length + " entries")
      }

      var sanitized = []
      for (var i = 0; i < postData.history.length; i++) {
        var item = postData.history[i]
        if (isUnDef(item) || isUnDef(item.event)) continue
        var entry = { event: item.event }
        if (isDef(item.message)) entry.message = item.message
        sanitized.push(entry)
      }

      global.__res[ postData.uuid ] = sanitized
      delete global.__conversations[ postData.uuid ]
      global.__lastActivity[ postData.uuid ] = Date.now()

      return ow.server.httpd.reply({ status: "loaded", uuid: postData.uuid, entries: sanitized.length })
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

ojob:
  opacks      :
  - openaf: 20250915
  - oJob-common
  - mini-a
  catch       : printErrnl("[" + job.name + "] "); $err(exception, __, __, job.exec)
  logToConsole: true   # to change when finished
  daemon      : true
  argsFromEnvs: true
  loadLibs    :
  - mini-a.js
  channels    :
    create:
    - name: conversations
    - name: lastActivity
    - name: results

jobs:
# ---------------------
- name : Static content
  exec : | #js
    args.path = getOPackPath("mini-a") + "/public"
  to   :
  - (httpdFileBrowse): "${onport:-8888}"
    ((uri          )): /
    #((path         )): public
    ((browse       )): false
    ((default      )): index.md

# -----------
- name : Init
  check:
    in:
      showexecs       : toBoolean().isBoolean().default(false)
      logpromptheaders: isString().default("")
      maxcontext      : toNumber().isNumber().default(200000)
      usehistory      : toBoolean().isBoolean().default(false)
      useattach       : toBoolean().isBoolean().default(false)
      historypath     : isString().default(".")
      historykeep     : toBoolean().isBoolean().default(false)
      useplanning     : toBoolean().isBoolean().default(false)
  exec : | #js
    global.__res = {}
    global.__usehistory = args.usehistory
    global.__historypath = args.historypath
    global.__historykeep = args.historykeep
    global.__conversations = {}
    global.__lastActivity = { }
    global.__showexecs = args.showexecs
    global.__logpromptheaders = args.logpromptheaders.split(",").map(h => h.trim().toLowerCase()).filter(h => h.length > 0)
    global.__useattach = args.useattach
    global.__planState = {}
    args.__format = "md"
    
    // Add system knowledge about visual diagram capabilities
    var visualDiagramKnowledge =
      "Visual output guidance (concise):\n\n" +
      "- Default to including a diagram or chart whenever structure, flow, hierarchy, metrics, or comparisons are involved.\n" +
      "- Always pair the visual with a short caption (1-2 sentences) summarizing the insight.\n\n" +
      "Mermaid diagrams:\n" +
      "  - Use ```mermaid``` fences for flows (`graph TD`), sequenceDiagram, stateDiagram-v2, classDiagram, erDiagram, gantt, mindmap, or pie charts.\n" +
      "  - Keep node labels concise and prefer directional edges for processes.\n\n" +
      "Chart.js visuals (strict format):\n" +
      "  - Wrap only the config object inside ```chart``` (aliases: chartjs, chart.js).\n" +
      "  - Include `type`, `data.labels`, and at least one dataset; add palettes and `options` as needed.\n" +
      "  - Optional `canvas: { width, height }` block controls sizing when helpful.\n" +
      "  - Never use other fences (json/javascript) and never return raw JSON.\n\n" +
      "Visual selection checklist:\n" +
      "1. Relationships or flows -> Mermaid `graph` or `sequenceDiagram`.\n" +
      "2. Timelines or roadmaps -> Mermaid `gantt`.\n" +
      "3. Comparisons or trends -> Chart.js `bar` or `line` chart.\n" +
      "4. Composition or ratios -> Chart.js `pie`/`doughnut`.\n\n" +
      "If a visual truly does not apply (e.g., purely narrative requests), explain why before falling back to text-only output."

    if (isUnDef(args.knowledge)) {
      args.knowledge = visualDiagramKnowledge
    } else {
      args.knowledge = args.knowledge + "\n\n" + visualDiagramKnowledge
    }
    
    global.maArgs = merge(args, {})
    //global.ma = new MiniA()
    //global.ma.init( global.maArgs )
    //global.ma = __

    global._mini_a_web_saveFile = (aFile, aMap) => {
      io.writeFileJSON(aFile, aMap, "")
    }

    global._mini_a_web_loadFile = (aFile) => {
      // Can be __
      return aFile
    }

# ---------------------------------------
- name : Periodic cleanup of old sessions
  type : periodic
  typeArgs:
    interval: 300000  # every 5 minutes
  args :
    historyretention: toNumber().isNumber().default(600)  # 10 minutes
  exec : | #js
    var toDelete = []
    for (var uuid in global.__lastActivity) {
      // If no activity for more than 5 minutes, delete session
      if (now() - global.__lastActivity[ uuid ] > args.historyretention * 1000) {
        toDelete.push(uuid)
      }
    }
    for (var i = 0; i < toDelete.length; i++) {
      var uuid = toDelete[i]
      delete global.__lastActivity[ uuid ]
      delete global.__res[ uuid ]
      delete global.__conversations[ uuid ]
      if (isDef(global.__planState) && isDef(global.__planState[ uuid ])) delete global.__planState[ uuid ]
      log("Cleaned up session " + uuid)
    }
