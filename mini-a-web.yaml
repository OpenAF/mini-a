# Author: Nuno Aguiar
help:
  text   : Mini-A web interface to interact with the Mini-A agent via HTTP. 
  expects: 
  - name     : onport
    desc     : Port to run the HTTP server on
    example  : "8888"
    mandatory: false
  - name     : showexecs
    desc     : Show executed commands in the interaction
    example  : "false"
    mandatory: false
    options  : ["true", "false"]
  - name     : usestream
    desc     : Stream LLM tokens in real-time via SSE
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : logpromptheaders
    desc     : Log prompt headers to console (for debugging)
    example  : "origin,referer"
    mandatory: false
  - name     : usehistory
    desc     : "Boolean to enable/disable history (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : useattach
    desc     : "Boolean to enable/disable file attachments (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : historypath
    desc     : "Path to store history files (default: .)"
    example  : "."
    mandatory: false
  - name     : historyretention
    desc     : "History retention period in seconds (default: 600)"
    example  : "600"
    mandatory: false
  - name     : historykeep
    desc     : "Boolean to keep history files (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : maxcontext
    desc     : "Maximum conversation tokens before Mini-A summarizes context (default: 200000)"
    example  : "200000"
    mandatory: false
  - name     : useplanning
    desc     : "Boolean to enable/disable task planning (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : updatefreq
    desc     : "Plan update frequency (auto, always, checkpoints, never)"
    example  : "auto"
    mandatory: false
  - name     : updateinterval
    desc     : "Steps between automatic plan updates when updatefreq=auto"
    example  : "3"
    mandatory: false
  - name     : forceupdates
    desc     : "Force plan updates even when actions fail"
    example  : "false"
    mandatory: false
    options  : ["true", "false"]
  - name     : planlog
    desc     : "Optional log file to append plan update entries"
    example  : "plan-updates.log"
    mandatory: false
  - name     : usediagrams
    desc     : "Boolean to enable/disable Mermaid diagram generation (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : usecharts
    desc     : "Boolean to enable/disable Chart.js chart generation (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : useascii
    desc     : "Boolean to enable/disable ASCII art sketch generation (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : historys3bucket
    desc     : "S3 bucket to store conversation history objects"
    example  : "mini-a-history"
    mandatory: false
  - name     : historys3prefix
    desc     : "Optional S3 key prefix for history objects"
    example  : "sessions/"
    mandatory: false
  - name     : historys3url
    desc     : "Custom S3-compatible endpoint URL"
    example  : "https://s3.amazonaws.com"
    mandatory: false
  - name     : historys3accesskey
    desc     : "Access key ID for the history S3 endpoint"
    example  : "AKIA..."
    mandatory: false
  - name     : historys3secret
    desc     : "Secret key for the history S3 endpoint"
    example  : "WJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
    mandatory: false
  - name     : historys3region
    desc     : "Region for the history S3 endpoint when required"
    example  : "eu-west-1"
    mandatory: false
  - name     : historys3useversion1
    desc     : "Force the MinIO client to use the S3 API version 1 when listing objects"
    example  : "false"
    mandatory: false
    options  : ["true", "false"]
  - name     : historys3ignorecertcheck
    desc     : "Ignore TLS certificate validation for the history S3 endpoint (use with caution)"
    example  : "false"
    mandatory: false
    options  : ["true", "false"]
  - name     : mcplazy
    desc     : "Initialize MCP connections lazily on first use instead of during Init"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : toolcachettl
    desc     : "Default cache TTL in milliseconds for MCP tool results"
    example  : "600000"
    mandatory: false
  - name     : useutils
    desc     : "Register Mini Utils Tool utilities as an MCP connection automatically"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : chatbotmode
    desc     : "Run Mini-A in chatbot mode without agent planning prompts"
    example  : "false"
    mandatory: false
    options  : ["true", "false"]
  - name     : format
    desc     : "Preferred Mini-A response format (md or json)"
    example  : "json"
    mandatory: false
  - name     : auditch
    desc     : "SLON/JSON definition of an audit channel for Mini-A interaction logs"
    example  : "(type: file, options: (file: '/tmp/mini-a-audit.log'))"
    mandatory: false

include:
- oJobHTTPd.yaml

todo:
- Init
- Periodic cleanup of old sessions
- Shutdown history S3 client
- (httpdStart     ): "${onport:-8888}"
  ((mapLibs      )): true
- (httpdHealthz   ): "${onport:-8888}"
- (httpdMetrics   ): "${onport:-8888}"
- Static content
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /ping
  ((execURI      )): | #js
    return ow.server.httpd.reply({ status: "ok" })

# Info about the server
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /info
  ((execURI      )): | #js
    try {
      var _res = { status: "ok", usehistory: global.__usehistory, useattach: global.__useattach, historyretention: args.historyretention, showexecs: global.__showexecs, usestream: global.__usestream }
      return ow.server.httpd.reply(_res)
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Clear a session
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /clear
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)
      // postData.force - to be used from the history pane to delete a specific session
      // __useHistory - if no history is being used, always clear
      if (!global.__usehistory || postData.force) {
        log("Clearing session " + postData.uuid)
        if (isDef(global.__res[ postData.uuid ])) {
          delete global.__res[ postData.uuid ]
        }
        if (isDef(global.__conversations[ postData.uuid ])) {
          delete global.__conversations[ postData.uuid ]
        }
        if (isDef(global.__lastActivity[ postData.uuid ])) {
          delete global.__lastActivity[ postData.uuid ]
        }
        if (isDef(global.__planState) && isDef(global.__planState[ postData.uuid ])) {
          delete global.__planState[ postData.uuid ]
        }
        if (global.__usehistory && !global.__historykeep) {
          log("Deleting history file for session " + postData.uuid)
          if (isFunction(global._mini_a_web_deleteHistory)) {
            global._mini_a_web_deleteHistory(postData.uuid)
          } else {
            // Fallback local cleanup
            var _hfile = global.__historypath + "/c-" + postData.uuid + ".json"
            if (io.fileExists(_hfile)) {
              io.rm(_hfile)
            }
          }
        }
      }
      return ow.server.httpd.reply({ status: "cleared" })
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Submit a prompt
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /prompt
  ((execURI      )): | #js
    var _res = { error: "check server logs" }
    try {
      
      // Parse POST data
      var postData = jsonParse(request.files.postData)
      // Validate UUID or generate a new one
      if (isDef(postData.uuid)) {
        _res.uuid = postData.uuid
      } else {
        _res.uuid = genUUID()
      }
      
      // Initialize response storage
      if (isUnDef(global.__res[_res.uuid])) {
        global.__res[ _res.uuid ] = [ ]
        global.__conversations[ _res.uuid ] = __
        global.__lastActivity[ _res.uuid ] = Date.now()
      } else {
        global.__lastActivity[ _res.uuid ] = Date.now()
      }
      
      // Prompt header logging
      if (global.__logpromptheaders.length > 0) {
        global.__logpromptheaders.forEach( h => {
          if (isDef(request.header[h])) {
            log("[" + _res.uuid + "] Prompt header " + h + ": " + request.header[h])
          }
        })
      }
      // Start Mini-A interaction in a non-blocking way
      $doV(() => {
        var uuid = _res.uuid, lma, isNewConversation = false
        if (global.__usestream && isFunction(global._mini_a_web_initSSE)) {
          global._mini_a_web_initSSE(uuid)
        }
        if (isDef(global.__planState) && isDef(global.__planState[ uuid ])) {
          delete global.__planState[ uuid ]
        }

        // If history is enabled, set the history file
        var _hfile = global.__usehistory ? global.__historypath + "/c-" + uuid + ".json" : __

        // If conversation does not exist, create it
        if (isUnDef(global.__conversations[ uuid ])) {
          isNewConversation = true
          // If history does not exist but we have history in memory, rebuild it
          if (global.__usehistory && !global._mini_a_web_historyExists(uuid) && isDef(global.__res[ uuid ]) && global.__res[ uuid ].length > 0) {
            // Try rebuilding
            var _data = []
            for (var i = 0; i < global.__res[ uuid ].length; i++) {
              var r = global.__res[ uuid ][i]
              if (r.event == "üë§") {
                _data.push( { role: "user", content: r.message } )
              } else if (r.event == "ü§ñ" || r.event == "‚¨ÖÔ∏è") {
                _data.push( { role: "assistant", content: r.message } )
              } else if (r.event == "‚öôÔ∏è" || r.event == "üñ•Ô∏è") {
                _data.push( { role: "system", content: r.message } )
              }
            }
            if (_data.length > 0) {
              global._mini_a_web_saveFile(_hfile, { u: new Date(), c: _data })
              log("[" + uuid + "] Rebuilt history file " + _hfile)
            }
          }
      
          // Initialize MiniA
          lma = new MiniA()
          lma.init(merge(global.maArgs, {
            conversation: global._mini_a_web_loadFile(_hfile)
          }))
          lma.setInteractionFn( (e, m) => {
            try {
              if (e == "stream") {
                if (global.__usestream && isFunction(global._mini_a_web_ssePush)) {
                  global._mini_a_web_ssePush(uuid, "stream", { message: m })
                }
                return
              }
              var _e = ""
              switch(e) {
              case "user"     : _e = "üë§"; break
              case "exec"     : _e = "‚öôÔ∏è"; break
              case "shell"    : _e = "üñ•Ô∏è"; break
              case "think"    : _e = "üí°"; break
              case "final"    : _e = "üèÅ"; break
              case "input"    : _e = "‚û°Ô∏è"; break
              case "output"   : _e = "‚¨ÖÔ∏è"; break
              case "thought"  : _e = "üí≠"; break
              case "think"    : _e = "üí°"; break
              case "size"     : _e = "üìè"; break
              case "rate"     : _e = "‚è≥"; break
              case "mcp"      : _e = "ü§ñ"; break
              case "plan"     : _e = "üó∫Ô∏è"; break
              case "done"     : _e = "‚úÖ"; break
              case "error"    : _e = "‚ùå"; break
              case "libs"     : _e = "üìö"; break
              case "info"     : _e = "‚ÑπÔ∏è"; break
              case "load"     : _e = "üìÇ"; break
              case "mcp"      : _e = "ü§ñ"; break
              case "warn"     : _e = "‚ö†Ô∏è"; break
              case "stop"     : _e = "üõë"; break
              case "error"    : _e = "‚ùó"; break
              case "summarize": _e = "üåÄ"; break
              default         : _e = e
              }

              if (_e == "üó∫Ô∏è") {
                try {
                  if (isFunction(lma._normalizePlanItems)) {
                    var planItems = lma._normalizePlanItems(isObject(lma._agentState) ? lma._agentState.plan : __)
                    if (isArray(planItems) && planItems.length > 0) {
                      var statusIcons = {
                        pending     : { icon: "‚è≥", label: "pending" },
                        todo        : { icon: "‚è≥", label: "to do" },
                        not_started : { icon: "‚è≥", label: "not started" },
                        ready       : { icon: "‚è≥", label: "ready" },
                        in_progress : { icon: "‚öôÔ∏è", label: "in progress" },
                        progressing : { icon: "‚öôÔ∏è", label: "in progress" },
                        working     : { icon: "‚öôÔ∏è", label: "working" },
                        running     : { icon: "‚öôÔ∏è", label: "running" },
                        active      : { icon: "‚öôÔ∏è", label: "active" },
                        done        : { icon: "‚úÖ", label: "done" },
                        complete    : { icon: "‚úÖ", label: "complete" },
                        completed   : { icon: "‚úÖ", label: "completed" },
                        finished    : { icon: "‚úÖ", label: "finished" },
                        success     : { icon: "‚úÖ", label: "success" },
                        blocked     : { icon: "üõë", label: "blocked" },
                        stuck       : { icon: "üõë", label: "stuck" },
                        paused      : { icon: "‚è∏Ô∏è", label: "paused" },
                        waiting     : { icon: "‚è≥", label: "waiting" },
                        failed      : { icon: "‚ùå", label: "failed" },
                        cancelled   : { icon: "üö´", label: "cancelled" },
                        canceled    : { icon: "üö´", label: "cancelled" }
                      }
                      var doneStatuses = {
                        done: true,
                        complete: true,
                        completed: true,
                        finished: true,
                        success: true
                      }
                      var normalized = []
                      for (var i = 0; i < planItems.length; i++) {
                        var entry = planItems[i] || {}
                        var statusKey = (entry.status || entry.rawStatus || "").toString()
                        var statusInfo = statusIcons[statusKey] || { icon: "‚Ä¢", label: statusKey || "pending" }
                        var isDone = doneStatuses[statusKey] === true || statusInfo.icon == "‚úÖ"
                        normalized.push({
                          title   : entry.title || ("Step " + (i + 1)),
                          status  : statusKey,
                          icon    : statusInfo.icon,
                          label   : statusInfo.label,
                          done    : isDone === true,
                          rawStatus: entry.rawStatus
                        })
                      }
                      var completedCount = 0
                      normalized.forEach(item => { if (item.done === true) completedCount++ })

                      var progressInfo = isObject(lma._planningProgress) ? lma._planningProgress : {}
                      var overallProgress = 0
                      if (isNumber(progressInfo.overall)) {
                        overallProgress = Math.max(0, Math.min(100, Math.round(progressInfo.overall)))
                      } else if (normalized.length > 0) {
                        overallProgress = Math.round((completedCount / normalized.length) * 100)
                      }

                      var checkpointInfo = { reached: 0, total: 0 }
                      if (isObject(progressInfo.checkpoints)) {
                        var checkpoints = progressInfo.checkpoints
                        if (isNumber(checkpoints.reached)) checkpointInfo.reached = checkpoints.reached
                        if (isNumber(checkpoints.total)) checkpointInfo.total = checkpoints.total
                      }

                      global.__planState[uuid] = {
                        items      : normalized,
                        total      : normalized.length,
                        completed  : completedCount,
                        overall    : overallProgress,
                        checkpoints: checkpointInfo,
                        active     : normalized.length > 0,
                        updated    : Date.now()
                      }
                      if (global.__usestream && isFunction(global._mini_a_web_ssePush)) {
                        global._mini_a_web_ssePush(uuid, "plan", { plan: global.__planState[uuid] })
                      }
                    } else {
                      if (isDef(global.__planState[uuid])) delete global.__planState[uuid]
                    }
                  }
                } catch(planErr) {
                  logErr(planErr)
                }
              //} else if (_e == "üèÅ" || _e == "‚úÖ" || _e == "‚ùå") {
              } else if (_e == "üèÅ" || _e == "üõë") {
                if (isDef(global.__planState[uuid])) {
                  log(`[${uuid}] ${_e} Plan closed`)
                  delete global.__planState[uuid]
                }
                if (_e == "üõë" && global.__usestream && isFunction(global._mini_a_web_sseClose)) {
                  global._mini_a_web_sseClose(uuid, "stopped")
                }
              }
              global.__res[uuid].push({ event: _e, message: m })
              // Only sync to S3 after user prompts (not on every event)
              if (_e == "üë§" && isFunction(global._mini_a_web_storeHistory)) {
                try {
                  global._mini_a_web_storeHistory(uuid)
                } catch(syncErr) {
                  logErr(syncErr)
                }
              }
              log("[" + uuid + "] " + _e + " " + m)
            } catch(eee) {
              $err(eee)
              logWarn(`[${uuid}] Plan closed`)
              delete global.__planState[uuid]
            }
          })
          global.__conversations[ uuid ] = lma
        } else {
          lma = global.__conversations[ uuid ]
        }

        // Only load conversation from file/S3 if this is a new MiniA instance
        // Otherwise use the in-memory conversation to preserve tool results
        var startArgs = merge(global.maArgs, {
          goal        : postData.prompt,
          raw         : true
        })
        // Only pass conversation parameter for new conversations to avoid overwriting in-memory state
        if (isNewConversation) {
          startArgs.conversation = global._mini_a_web_loadFile(_hfile)
        }
        var _rma = lma.start(startArgs)

        if (isDef(_rma.answer)) {
          var trimmedAnswer = _rma.answer.trim();
          if (trimmedAnswer.startsWith("```markdown") && trimmedAnswer.endsWith("```")) {
            // Remove markdown fences
            _rma.answer = trimmedAnswer.replace(/^```markdown\s*\n?([\s\S]+?)\n?```$/g, "$1").trim()
          }
        }
        global.__res[uuid].push( { event: "final", message: (isObject(_rma) ? af.toSLON(_rma) : _rma) } )
        if (global.__usestream && isFunction(global._mini_a_web_sseClose)) {
          global._mini_a_web_sseClose(uuid, "finished")
        }
        if (isFunction(global._mini_a_web_storeHistory)) {
          try {
            global._mini_a_web_storeHistory(uuid)
          } catch(storeErr) {
            logErr(storeErr)
          }
        }
        log("[" + uuid + "] " + (isObject(_rma) ? af.toSLON(_rma) : _rma))
      }).catch((eee) => {
        logErr(eee)
        $err(eee)
      })
    } catch(ee) {
      logErr(ee)
      $err(ee)
    }

    return ow.server.httpd.reply(_res)

# Get results of a prompt
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /result
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)

      if (isDef(postData.request) && postData.request == "stop") {
        global.__conversations[ postData.uuid ].state = "stop"
      }
      var _res = { content: "", status: "processing", history: [] }
      var __attachmentLangMap = {
        md: 'markdown', markdown: 'markdown', json: 'json', yaml: 'yaml', yml: 'yaml',
        csv: 'csv', tsv: 'tsv', xml: 'xml', html: 'html', htm: 'html', css: 'css', scss: 'scss', less: 'less',
        js: 'javascript', mjs: 'javascript', cjs: 'javascript', ts: 'typescript', jsx: 'jsx', tsx: 'tsx',
        py: 'python', rb: 'ruby', go: 'go', java: 'java', kt: 'kotlin', c: 'c', h: 'c', cpp: 'cpp', cc: 'cpp', hpp: 'cpp', cs: 'csharp',
        rs: 'rust', php: 'php', sh: 'bash', bash: 'bash', zsh: 'bash', fish: 'bash', sql: 'sql', toml: 'toml', ini: 'ini', cfg: 'ini', conf: 'ini', env: 'ini',
        properties: 'ini', gradle: 'groovy', dockerfile: 'dockerfile', makefile: 'makefile', cmake: 'cmake', r: 'r', lua: 'lua', swift: 'swift', scala: 'scala'
      }

      function __escapeHtml(str) {
        if (isUnDef(str)) return ''
        return ('' + str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;')
      }

      function __escapeAttr(str) {
        return __escapeHtml(str).replace(/[\r\n]+/g, ' ')
      }

      function __detectAttachmentLang(name) {
        if (isUnDef(name)) return 'text'
        var lowered = ('' + name).toLowerCase()
        if (lowered == 'dockerfile') return 'dockerfile'
        if (lowered.indexOf('makefile') == 0) return 'makefile'
        var parts = lowered.split('.')
        var ext = parts.length > 1 ? parts.pop() : ''
        if (isDef(__attachmentLangMap[ext])) return __attachmentLangMap[ext]
        return 'text'
      }

      function __formatUserMessage(message) {
        if (isUnDef(message)) return ''
        var text = '' + message
        var attachments = []
        text = text.replace(/```attachment\s+([^\n]+)\n([\s\S]*?)```/gm, function(_, name, content) {
          var cleanName = ('' + name).replace(/[\r\n]+/g, ' ').trim()
          var cleanContent = ('' + content).replace(/\r\n/g, '\n')
          attachments.push({ name: cleanName, content: cleanContent })
          return '¬ß¬ßATTACHMENT_' + (attachments.length - 1) + '¬ß¬ß'
        })

        var html = __escapeHtml(text).replace(/\n/g, '<br>')
        for (var j = 0; j < attachments.length; j++) {
          var att = attachments[j]
          var placeholder = '¬ß¬ßATTACHMENT_' + j + '¬ß¬ß'
          var safeName = att.name && att.name.length > 0 ? att.name : 'attachment.txt'
          var safeNameHtml = __escapeHtml(safeName)
          var attrName = __escapeAttr(safeName)
          var encoded = af.fromBytes2String(af.toBase64Bytes(att.content || ''))
          var language = __detectAttachmentLang(att.name)
          var button = '<button class="user-attachment" type="button" data-name="' + attrName + '" data-language="' + __escapeAttr(language) + '" data-content="' + __escapeAttr(encoded) + '">üìé ' + safeNameHtml + '</button>'
          html = html.replace(placeholder, button)
        }

        return html
      }
      if (isDef(global.__res[ postData.uuid ])) {
        // Update last activity
        global.__lastActivity[ postData.uuid ] = Date.now()
        var planState = isDef(global.__planState) ? global.__planState[ postData.uuid ] : __
        var hasActivePlan = isDef(planState) && isArray(planState.items) && planState.items.length > 0

        // Append all messages to content
        var _history = []
        for (var i = 0; i < global.__res[ postData.uuid ].length; i++) {
          var r = global.__res[ postData.uuid ][i]
          if (isDef(r.event)) {
            var _h = { event: r.event }
            if (isDef(r.message)) _h.message = r.message
            _history.push(_h)
          }
          if (r.event == "final") {
            if (i == global.__res[ postData.uuid ].length - 1) _res.status = "finished"
            _res.content += "\n" + r.message + "\n"
            //delete global.__res[ postData.uuid ]
            //break
          } else {
            // Exclude planning (üó∫Ô∏è) messages from the content log; plan panel remains driven by __planState
            if (r.event == "üë§" || (r.event == "‚öôÔ∏è" && global.__showexecs) || (r.event == "üñ•Ô∏è" && global.__showexecs) || r.event == "üí°" || r.event == "üí≠" || r.event == "üåÄ" || r.event == "üõë" || r.event == "‚è≥") {
              if (r.event == "üë§") {
                _res.content += "<div style=\"text-align: right;\"><i><div style=\"display: inline-block; text-align: left;\">" + __formatUserMessage(r.message) + "</div> " + r.event + "</i>\n<br><br></div>"
              } else {
                _res.content += r.event + " <i><span style=\"color: var(--text); opacity: 0.60;\">" + r.message.replace(/\n/g, "<br>") + "</span></i>\n"
              }
            }
          }
        }
        _res.history = _history
        if (hasActivePlan) {
          _res.plan = {
            active     : true,
            items      : planState.items,
            total      : planState.total,
            completed  : planState.completed,
            overall    : planState.overall,
            checkpoints: planState.checkpoints,
            updated    : planState.updated
          }
        } else {
          _res.plan = {
            active     : false,
            items      : [],
            total      : 0,
            completed  : 0,
            overall    : 0,
            checkpoints: { reached: 0, total: 0 }
          }
        }
      }

      return ow.server.httpd.reply(_res)
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Stream events via SSE
- (httpdSSE       ): "${onport:-8888}"
  ((uri          )): /stream
  ((execSSE      )): | #js
    var uuid = __
    try {
      uuid = isDef(request.params) ? request.params.uuid : __
      if (isUnDef(uuid) || String(uuid).length == 0) {
        writer.write("error", { message: "uuid is required" })
        return
      }
      if (isUnDef(global.__sseQueues[uuid])) {
        global.__sseQueues[uuid] = { events: [], closed: false, updated: Date.now() }
      }
      var idx = 0
      var lastPing = Date.now()
      writer.write("ready", { status: "ok", uuid: uuid })
      while (true) {
        var queue = global.__sseQueues[uuid]
        if (isUnDef(queue)) break
        while (idx < queue.events.length) {
          var entry = queue.events[idx]
          writer.write(entry.event, entry.data)
          idx++
          lastPing = Date.now()
        }
        if (queue.closed) break
        if ((Date.now() - lastPing) > 15000) {
          writer.write("ping", { ts: Date.now() })
          lastPing = Date.now()
        }
        sleep(100)
      }
    } catch(e) {
      // Mark queue as closed on error (e.g., client disconnect)
      if (isDef(uuid) && isDef(global.__sseQueues[uuid])) {
        global.__sseQueues[uuid].closed = true
        global.__sseQueues[uuid].updated = Date.now()
      }
      try { 
        writer.write("error", { message: String(e) }) 
      } catch(writeErr) {
        log("Failed to write error response for SSE" + (isDef(uuid) ? " " + uuid : "") + ": " + writeErr)
      }
    } finally {
      // Clean up on exit (normal or error); periodic job handles edge cases
      if (isDef(uuid) && isDef(global.__sseQueues[uuid])) {
        // Queue.closed is true in two cases:
        // 1. Normal completion: _mini_a_web_sseClose() sets closed=true, loop exits
        // 2. Error/disconnect: catch block sets closed=true
        if (global.__sseQueues[uuid].closed) {
          delete global.__sseQueues[uuid]
        }
      }
    }

# Convert markdown to static HTML
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /md2html
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)
      var markdown = (isDef(postData.markdown) ? ("" + postData.markdown) : "").trim()

      if (markdown.length == 0) {
        return ow.server.httpd.reply({ error: "markdown is required" })
      }

      var html = ow.template.html.genStaticVersion4MD(markdown)

      if (isDef(global.__webMetrics) && isDef(global.__webMetrics.html_exports) && isFunction(global.__webMetrics.html_exports.inc)) {
        try { global.__webMetrics.html_exports.inc() } catch(ignore) {}
      }

      return ow.server.httpd.reply({ html: html })
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Load history for a session
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /load-history
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)

      if (isUnDef(postData.uuid)) {
        return ow.server.httpd.reply({ error: "uuid is required" })
      }

      if (isUnDef(postData.history) || !Array.isArray(postData.history)) {
        return ow.server.httpd.reply({ error: "history must be an array" })
      }

      // If already stored no need to load again
      if (isDef(global.__res[ postData.uuid ])) {
        logWarn("History for " + postData.uuid + " already loaded")
        return ow.server.httpd.reply({ status: "loaded", uuid: postData.uuid, entries: global.__res[ postData.uuid ].length })
      } else {
        logWarn("History for " + postData.uuid + " not found. Rebuilding from provided history with " + postData.history.length + " entries")
      }

      var sanitized = []
      for (var i = 0; i < postData.history.length; i++) {
        var item = postData.history[i]
        if (isUnDef(item) || isUnDef(item.event)) continue
        var entry = { event: item.event }
        if (isDef(item.message)) entry.message = item.message
        sanitized.push(entry)
      }

      global.__res[ postData.uuid ] = sanitized
      delete global.__conversations[ postData.uuid ]
      global.__lastActivity[ postData.uuid ] = Date.now()
      if (isFunction(global._mini_a_web_storeHistory)) {
        try {
          global._mini_a_web_storeHistory(postData.uuid)
        } catch(syncErr) {
          logErr(syncErr)
        }
      }

      return ow.server.httpd.reply({ status: "loaded", uuid: postData.uuid, entries: sanitized.length })
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

ojob:
  opacks      :
  - openaf: 20250915
  - oJob-common
  - mini-a
  - S3
  catch       : printErrnl("[" + job.name + "] "); printErr(exception)
  logToConsole: true   # to change when finished
  daemon      : true
  argsFromEnvs: true
  loadLibs    :
  - mini-a.js
  - s3.js
  channels    :
    create:
    - name: conversations
    - name: lastActivity
    - name: results

jobs:
# ---------------------
- name : CheckEnv
  exec : | #js
    var hasModelOverride = isDef(args) && isDef(args.model) && ((isString(args.model) && args.model.trim().length > 0) || isMap(args.model))
    if (isUnDef(getEnv("OAF_MODEL")) && !hasModelOverride) {
      throw "OAF_MODEL environment variable not set. Please export OAF_MODEL or provide model= with your model configuration before starting the Mini-A web server."
    }

# ---------------------
- name : Static content
  exec : | #js
    args.path = getOPackPath("mini-a") + "/public"
  to   :
  - (httpdFileBrowse): "${onport:-8888}"
    ((uri          )): /
    #((path         )): public
    ((browse       )): false
    ((default      )): index.md

# -----------
- name : Init
  from :
  - CheckEnv
  check:
    in:
      showexecs       : toBoolean().isBoolean().default(false)
      usestream       : toBoolean().isBoolean().default(false)
      logpromptheaders: isString().default("")
      maxcontext      : toNumber().isNumber().default(200000)
      usehistory      : toBoolean().isBoolean().default(false)
      useattach       : toBoolean().isBoolean().default(false)
      historypath     : isString().default(".")
      historykeep     : toBoolean().isBoolean().default(false)
      useplanning     : toBoolean().isBoolean().default(false)
      updatefreq      : isString().default("auto")
      updateinterval  : toNumber().isNumber().default(3)
      forceupdates    : toBoolean().isBoolean().default(false)
      planlog         : isString().default(__)
      usediagrams     : toBoolean().isBoolean().default(false)
      usecharts       : toBoolean().isBoolean().default(false)
      useascii        : toBoolean().isBoolean().default(false)
      historys3bucket : isString().default(__)
      historys3prefix : isString().default("")
      historys3url    : isString().default("https://s3.amazonaws.com")
      historys3accesskey: isString().default(__)
      historys3secret : isString().default(__)
      historys3region : isString().default(__)
      historys3useversion1: toBoolean().isBoolean().default(false)
      historys3ignorecertcheck: toBoolean().isBoolean().default(false)
      mcplazy        : toBoolean().isBoolean().default(false)
      toolcachettl   : toNumber().isNumber().default(__)
      useutils       : toBoolean().isBoolean().default(false)
      chatbotmode    : toBoolean().isBoolean().default(false)
      format         : isString().default(__)
      auditch        : isString().default(__)
  exec : | #js
    global.__res = {}
    global.__usehistory = args.usehistory
    global.__historypath = args.historypath
    global.__historykeep = args.historykeep
    global.__conversations = {}
    global.__lastActivity = { }
    global.__showexecs = args.showexecs
    global.__usestream = args.usestream
    global.__logpromptheaders = args.logpromptheaders.split(",").map(h => h.trim().toLowerCase()).filter(h => h.length > 0)
    global.__useattach = args.useattach
    global.__planState = {}
    global.__sseQueues = {}
    if (isUnDef(global.__webMetrics)) {
      global.__webMetrics = { html_exports: $atomic(0, "long") }
      try {
        ow.metrics.add("mini-a-web", () => {
          return { html_exports: global.__webMetrics.html_exports.get() }
        })
      } catch(metricsErr) {
        logErr(metricsErr)
      }
    }
    if (global.__usehistory && isString(global.__historypath)) {
      try {
        io.mkdir(global.__historypath)
      } catch(ignore) {}
    }

    global.__historys3bucket = args.historys3bucket
    global.__historys3client = __
    global.__historys3enabled = false
    global.__historys3prefix = isString(args.historys3prefix) ? String(args.historys3prefix) : ""
    if (global.__historys3prefix.length > 0) {
      while (global.__historys3prefix.charAt(0) == "/") {
        global.__historys3prefix = global.__historys3prefix.substring(1)
      }
      while (global.__historys3prefix.length > 0 && global.__historys3prefix.charAt(global.__historys3prefix.length - 1) == "/") {
        global.__historys3prefix = global.__historys3prefix.substring(0, global.__historys3prefix.length - 1)
      }
    }

    if (global.__usehistory && isString(global.__historys3bucket) && global.__historys3bucket.length > 0) {
      try {
        global.__historys3client = new S3(args.historys3url, args.historys3accesskey, args.historys3secret, args.historys3region, args.historys3useversion1, args.historys3ignorecertcheck)
        global.__historys3enabled = true
        log("History S3 storage enabled for bucket " + global.__historys3bucket + (global.__historys3prefix.length > 0 ? (" with prefix " + global.__historys3prefix) : ""))
      } catch(initErr) {
        logErr(initErr)
        global.__historys3client = __
        global.__historys3enabled = false
      }
    }

    if (isUnDef(args.__format)) {
      args.__format = isDef(args.format) ? args.format : "md"
    }
    
    global.maArgs = merge(args, {})
    if (!toBoolean(args.mcplazy)) {
      var _ma = new MiniA()
      _ma.init( merge( global.maArgs, { mcpdynamic: false } ) )
      _ma = __
    }

    global._mini_a_web_historyS3Key = (uuid) => {
      if (isUnDef(uuid)) return __
      var clean = String(uuid)
      var key = "c-" + clean + ".json"
      if (global.__historys3prefix.length > 0) {
        key = global.__historys3prefix + "/" + key
      }
      return key
    }

    global._mini_a_web_uuidFromPath = (aFile) => {
      if (isUnDef(aFile) || isUnDef(global.__historypath)) return __
      var base = String(global.__historypath)
      if (base.length > 0 && base.charAt(base.length - 1) != "/") {
        base = base + "/"
      }
      var prefix = base + "c-"
      var file = String(aFile || "")
      if (file.indexOf(prefix) == 0 && file.length > prefix.length + 5) {
        var uuid = file.substring(prefix.length)
        if (uuid.endsWith(".json")) {
          uuid = uuid.substring(0, uuid.length - 5)
        }
        return uuid
      }
      return __
    }

    global._mini_a_web_initSSE = (uuid) => {
      if (isUnDef(uuid)) return
      global.__sseQueues[uuid] = { events: [], closed: false, updated: Date.now() }
    }

    global._mini_a_web_ssePush = (uuid, event, data) => {
      if (!global.__usestream) return
      if (isUnDef(uuid) || isUnDef(event)) return
      if (isUnDef(global.__sseQueues[uuid])) {
        global.__sseQueues[uuid] = { events: [], closed: false, updated: Date.now() }
      }
      global.__sseQueues[uuid].events.push({ event: event, data: data })
      global.__sseQueues[uuid].updated = Date.now()
    }

    global._mini_a_web_sseClose = (uuid, status) => {
      if (!global.__usestream) return
      if (isUnDef(uuid)) return
      if (isUnDef(global.__sseQueues[uuid])) {
        global.__sseQueues[uuid] = { events: [], closed: false, updated: Date.now() }
      }
      if (global.__sseQueues[uuid].closed === true) return
      global.__sseQueues[uuid].events.push({ event: "done", data: { status: status || "finished" } })
      global.__sseQueues[uuid].closed = true
      global.__sseQueues[uuid].updated = Date.now()
    }

    global._mini_a_web_buildHistoryPayload = (uuid) => {
      if (isUnDef(uuid)) return __
      var hfile = global.__historypath + "/c-" + uuid + ".json"

      // Prefer S3 when enabled
      if (global.__historys3enabled) {
        var stream, str
        try {
          var key = global._mini_a_web_historyS3Key(uuid)
          log("S3 history get (payload) bucket=" + global.__historys3bucket + " key=" + key)
          stream = global.__historys3client.getObjectStream(global.__historys3bucket, key)
          str = af.fromInputStream2String(stream)
        } catch(getErr) {
          // Ignore missing objects; log other errors
          if (isDef(getErr) && String(getErr).indexOf("NoSuchKey") < 0) {
            logErr(getErr)
          }
        } finally {
          if (isDef(stream)) { try { stream.close() } catch(ignore) {} }
        }
        if (isDef(str)) {
          try {
            log("S3 history got payload for uuid=" + uuid + " size=" + str.length)
            return str
          } catch(convErr) { logErr(convErr) }
        }
      }

      // Otherwise try local file if present
      if (io.fileExists(hfile)) {
        try {
          return io.readFileString(hfile)
        } catch(readErr) {
          logErr(readErr)
        }
      }

      // Build from in-memory events
      if (isDef(global.__res[uuid]) && isArray(global.__res[uuid]) && global.__res[uuid].length > 0) {
        var data = []
        for (var i = 0; i < global.__res[uuid].length; i++) {
          var entry = global.__res[uuid][i]
          if (isUnDef(entry) || isUnDef(entry.event)) continue
          var msg = isDef(entry.message) ? entry.message : ""
          switch(entry.event) {
          case "üë§":
            data.push({ role: "user", content: msg })
            break
          case "ü§ñ":
          case "‚¨ÖÔ∏è":
          case "üèÅ":
          case "‚úÖ":
          case "‚ùå":
            data.push({ role: "assistant", content: msg })
            break
          case "‚öôÔ∏è":
          case "üñ•Ô∏è":
          case "üìö":
          case "‚ÑπÔ∏è":
          case "üìÇ":
          case "‚ö†Ô∏è":
          case "üõë":
            data.push({ role: "system", content: msg })
            break
          default:
            // Skip remaining events from being persisted
          }
        }
        if (data.length > 0) {
          return stringify({ u: new Date(), c: data }, __, "")
        }
      }
      return __
    }

    global._mini_a_web_storeHistory = (uuid) => {
      if (!global.__historys3enabled) return
      var payload = global._mini_a_web_buildHistoryPayload(uuid)
      if (isUnDef(payload)) return
      var stream, bytes
      try {
        var key = global._mini_a_web_historyS3Key(uuid)
        log("S3 history put bucket=" + global.__historys3bucket + " key=" + key + " size=" + (isDef(payload) ? payload.length : 0))
        global.__historys3client.putObjectStream(global.__historys3bucket, key, af.fromString2InputStream(payload), {}, "application/json")
      } catch(storeErr) {
        logErr(storeErr)
      } finally {
        if (isDef(stream)) {
          try { stream.close() } catch(ignore) {}
        }
      }
    }

    global._mini_a_web_deleteHistory = (uuid) => {
      if (isUnDef(uuid)) return
      var localFile = isString(global.__historypath) ? (global.__historypath + "/c-" + uuid + ".json") : __
      // Remove remote if enabled
      if (global.__historys3enabled) {
        try {
          var key = global._mini_a_web_historyS3Key(uuid)
          log("S3 history delete bucket=" + global.__historys3bucket + " key=" + key)
          global.__historys3client.removeObject(global.__historys3bucket, key)
        } catch(removeErr) {
          logErr(removeErr)
        }
      }
      // Always try to remove local cache file if present
      if (isString(localFile) && io.fileExists(localFile)) {
        try { io.rm(localFile) } catch(ignore) {}
      }
    }

    global._mini_a_web_saveFile = (aFile, aMap) => {
      var uuid = global._mini_a_web_uuidFromPath(aFile)
      if (global.__historys3enabled && isDef(uuid)) {
        // Save to S3 instead of local
        var payload
        try {
          payload = stringify(aMap, __, "")
        } catch(jsonErr) { logErr(jsonErr); return }
        var stream, bytes
        try {
          var key = global._mini_a_web_historyS3Key(uuid)
          bytes = af.fromString2Bytes(payload, "utf-8")
          log("S3 history save bucket=" + global.__historys3bucket + " key=" + key + " size=" + (isDef(bytes) ? bytes.length : 0))
          stream = new Packages.java.io.ByteArrayInputStream(bytes)
          global.__historys3client.putObjectStream(global.__historys3bucket, key, stream, {}, "application/json")
        } catch(storeErr) {
          logErr(storeErr)
        } finally {
          if (isDef(stream)) { try { stream.close() } catch(ignore) {} }
        }
      } else {
        // Local save
        try { io.writeFileJSON(aFile, aMap, "") } catch(writeErr) { logErr(writeErr) }
      }
    }

    global._mini_a_web_historyExists = (uuid) => {
      if (isUnDef(uuid)) return false
      var localFile = isString(global.__historypath) ? (global.__historypath + "/c-" + uuid + ".json") : __
      if (global.__historys3enabled) {
        var stream
        try {
          var key = global._mini_a_web_historyS3Key(uuid)
          log("S3 history exists? bucket=" + global.__historys3bucket + " key=" + key)
          stream = global.__historys3client.getObjectStream(global.__historys3bucket, key)
          log("S3 history exists: true for key=" + key)
          return true
        } catch(getErr) {
          // Missing object is not an error
          try { if (String(getErr).indexOf("NoSuchKey") >= 0) log("S3 history exists: false for key=" + global._mini_a_web_historyS3Key(uuid)) } catch(ignore) {}
          return false
        } finally {
          if (isDef(stream)) { try { stream.close() } catch(ignore) {} }
        }
      }
      return isString(localFile) && io.fileExists(localFile)
    }

    global._mini_a_web_loadFile = (aFile) => {
      // Can be __
      if (global.__historys3enabled && isString(aFile)) {
        var uuid = global._mini_a_web_uuidFromPath(aFile)
        if (isDef(uuid)) {
          var stream, str
          try {
            var key = global._mini_a_web_historyS3Key(uuid)
            log("S3 history get (load) bucket=" + global.__historys3bucket + " key=" + key + " -> file=" + aFile)
            stream = global.__historys3client.getObjectStream(global.__historys3bucket, key)
            str = af.fromInputStream2String(stream)
          } catch(getErr) {
            // Ignore missing objects
            if (isDef(getErr) && String(getErr).indexOf("NoSuchKey") < 0) {
              logErr(getErr)
            }
          } finally {
            if (isDef(stream)) {
              try { stream.close() } catch(ignore) {}
            }
          }
          if (isDef(str)) {
            try {
              log("S3 history downloaded uuid=" + uuid + " size=" + str.length + " -> " + aFile)
              io.writeFileString(aFile, str)
            } catch(writeErr) {
              logErr(writeErr)
            }
          }
        }
      }
      return aFile
    }

# ---------------------------------------
- name : Periodic cleanup of old sessions
  type : periodic
  typeArgs:
    interval: 300000  # every 5 minutes
  args :
    historyretention: toNumber().isNumber().default(600)  # 10 minutes
    ssequeuetimeout: toNumber().isNumber().default(120)   # SSE queue timeout in seconds (2 minutes)
  exec : | #js
    var toDelete = []
    for (var uuid in global.__lastActivity) {
      // If no activity for more than 5 minutes, delete session
      if (now() - global.__lastActivity[ uuid ] > args.historyretention * 1000) {
        toDelete.push(uuid)
      }
    }
    for (var i = 0; i < toDelete.length; i++) {
      var uuid = toDelete[i]
      delete global.__lastActivity[ uuid ]
      delete global.__res[ uuid ]
      delete global.__conversations[ uuid ]
      if (isDef(global.__planState) && isDef(global.__planState[ uuid ])) delete global.__planState[ uuid ]
      if (global.__usehistory && !global.__historykeep && isFunction(global._mini_a_web_deleteHistory)) {
        try {
          global._mini_a_web_deleteHistory(uuid)
        } catch(cleanErr) {
          logErr(cleanErr)
        }
      }
      log("Cleaned up session " + uuid)
    }

    // Clean up stale SSE queues (prevent memory leaks from abrupt disconnections)
    var sseTimeoutMs = args.ssequeuetimeout * 1000
    var sseToDelete = []
    for (var uuid in global.__sseQueues) {
      var queue = global.__sseQueues[uuid]
      // Remove queues that are closed or haven't been updated within the timeout period
      if (isDef(queue) && (queue.closed || (isDef(queue.updated) && Date.now() - queue.updated > sseTimeoutMs))) {
        sseToDelete.push(uuid)
      }
    }
    for (var i = 0; i < sseToDelete.length; i++) {
      var uuid = sseToDelete[i]
      delete global.__sseQueues[uuid]
      log("Cleaned up SSE queue " + uuid)
    }

# ---------------------------------------
- name : Shutdown history S3 client
  type : shutdown
  exec : | #js
    if (isDef(global.__historys3client)) {
      try { global.__historys3client.close() } catch(ignore) {}
      global.__historys3client = __
      global.__historys3enabled = false
    }
