# Author: Nuno Aguiar
help:
  text   : Mini-A web interface to interact with the Mini-A agent via HTTP. 
  expects: 
  - name     : onport
    desc     : Port to run the HTTP server on
    example  : "8888"
    mandatory: false
  - name     : showexecs
    desc     : Show executed commands in the interaction
    example  : "false"
    mandatory: false
    options  : ["true", "false"]
  - name     : logpromptheaders
    desc     : Log prompt headers to console (for debugging)
    example  : "origin,referer"
    mandatory: false
  - name     : usehistory
    desc     : "Boolean to enable/disable history (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : useattach
    desc     : "Boolean to enable/disable file attachments (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : historypath
    desc     : "Path to store history files (default: .)"
    example  : "."
    mandatory: false
  - name     : historyretention
    desc     : "History retention period in seconds (default: 600)"
    example  : "600"
    mandatory: false
  - name     : historykeep
    desc     : "Boolean to keep history files (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : maxcontext
    desc     : "Maximum conversation tokens before Mini-A summarizes context (default: 200000)"
    example  : "200000"
    mandatory: false
  - name     : useplanning
    desc     : "Boolean to enable/disable task planning (default: false)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : usediagrams
    desc     : "Boolean to enable/disable Mermaid diagram generation (default: true)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : usecharts
    desc     : "Boolean to enable/disable Chart.js chart generation (default: true)"
    example  : "true"
    mandatory: false
    options  : ["true", "false"]
  - name     : historys3bucket
    desc     : "S3 bucket to store conversation history objects"
    example  : "mini-a-history"
    mandatory: false
  - name     : historys3prefix
    desc     : "Optional S3 key prefix for history objects"
    example  : "sessions/"
    mandatory: false
  - name     : historys3url
    desc     : "Custom S3-compatible endpoint URL"
    example  : "https://s3.amazonaws.com"
    mandatory: false
  - name     : historys3accesskey
    desc     : "Access key ID for the history S3 endpoint"
    example  : "AKIA..."
    mandatory: false
  - name     : historys3secret
    desc     : "Secret key for the history S3 endpoint"
    example  : "WJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
    mandatory: false
  - name     : historys3region
    desc     : "Region for the history S3 endpoint when required"
    example  : "eu-west-1"
    mandatory: false
  - name     : historys3useversion1
    desc     : "Force the MinIO client to use the S3 API version 1 when listing objects"
    example  : "false"
    mandatory: false
    options  : ["true", "false"]
  - name     : historys3ignorecertcheck
    desc     : "Ignore TLS certificate validation for the history S3 endpoint (use with caution)"
    example  : "false"
    mandatory: false
    options  : ["true", "false"]

include:
- oJobHTTPd.yaml

todo:
- Init
- Periodic cleanup of old sessions
- Shutdown history S3 client
- (httpdStart     ): "${onport:-8888}"
  ((mapLibs      )): true
- (httpdHealthz   ): "${onport:-8888}"
- (httpdMetrics   ): "${onport:-8888}"
- Static content
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /ping
  ((execURI      )): | #js
    return ow.server.httpd.reply({ status: "ok" })

# Info about the server
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /info
  ((execURI      )): | #js
    try {
      var _res = { status: "ok", usehistory: global.__usehistory, useattach: global.__useattach, historyretention: args.historyretention, showexecs: global.__showexecs }
      return ow.server.httpd.reply(_res)
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Clear a session
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /clear
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)
      // postData.force - to be used from the history pane to delete a specific session
      // __useHistory - if no history is being used, always clear
      if (!global.__usehistory || postData.force) {
        log("Clearing session " + postData.uuid)
        if (isDef(global.__res[ postData.uuid ])) {
          delete global.__res[ postData.uuid ]
        }
        if (isDef(global.__conversations[ postData.uuid ])) {
          delete global.__conversations[ postData.uuid ]
        }
        if (isDef(global.__lastActivity[ postData.uuid ])) {
          delete global.__lastActivity[ postData.uuid ]
        }
        if (isDef(global.__planState) && isDef(global.__planState[ postData.uuid ])) {
          delete global.__planState[ postData.uuid ]
        }
        if (global.__usehistory && !global.__historykeep) {
          log("Deleting history file for session " + postData.uuid)
          if (isFunction(global._mini_a_web_deleteHistory)) {
            global._mini_a_web_deleteHistory(postData.uuid)
          } else {
            // Fallback local cleanup
            var _hfile = global.__historypath + "/c-" + postData.uuid + ".json"
            if (io.fileExists(_hfile)) {
              io.rm(_hfile)
            }
          }
        }
      }
      return ow.server.httpd.reply({ status: "cleared" })
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Submit a prompt
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /prompt
  ((execURI      )): | #js
    var _res = { error: "check server logs" }
    try {
      
      // Parse POST data
      var postData = jsonParse(request.files.postData)
      // Validate UUID or generate a new one
      if (isDef(postData.uuid)) {
        _res.uuid = postData.uuid
      } else {
        _res.uuid = genUUID()
      }
      
      // Initialize response storage
      if (isUnDef(global.__res[_res.uuid])) {
        global.__res[ _res.uuid ] = [ ]
        global.__conversations[ _res.uuid ] = __
        global.__lastActivity[ _res.uuid ] = Date.now()
      } else {
        global.__lastActivity[ _res.uuid ] = Date.now()
      }
      
      // Prompt header logging
      if (global.__logpromptheaders.length > 0) {
        global.__logpromptheaders.forEach( h => {
          if (isDef(request.header[h])) {
            log("[" + _res.uuid + "] Prompt header " + h + ": " + request.header[h])
          }
        })
      }
      // Start Mini-A interaction in a non-blocking way
      $doV(() => {
        var uuid = _res.uuid, lma
        if (isDef(global.__planState) && isDef(global.__planState[ uuid ])) {
          delete global.__planState[ uuid ]
        }

        // If history is enabled, set the history file
        var _hfile = global.__usehistory ? global.__historypath + "/c-" + uuid + ".json" : __

        // If conversation does not exist, create it
        if (isUnDef(global.__conversations[ uuid ])) {
          // If history does not exist but we have history in memory, rebuild it
          if (global.__usehistory && !global._mini_a_web_historyExists(uuid) && isDef(global.__res[ uuid ]) && global.__res[ uuid ].length > 0) {
            // Try rebuilding
            var _data = []
            for (var i = 0; i < global.__res[ uuid ].length; i++) {
              var r = global.__res[ uuid ][i]
              if (r.event == "👤") {
                _data.push( { role: "user", content: r.message } )
              } else if (r.event == "🤖" || r.event == "⬅️") {
                _data.push( { role: "assistant", content: r.message } )
              } else if (r.event == "⚙️" || r.event == "🖥️") {
                _data.push( { role: "system", content: r.message } )
              }
            }
            if (_data.length > 0) {
              global._mini_a_web_saveFile(_hfile, { u: new Date(), c: _data })
              log("[" + uuid + "] Rebuilt history file " + _hfile)
            }
          }
      
          // Initialize MiniA
          lma = new MiniA()
          lma.init(merge(global.maArgs, {
            conversation: global._mini_a_web_loadFile(_hfile)
          }))
          lma.setInteractionFn( (e, m) => {
            try {
              var _e = ""
              switch(e) {
              case "user"     : _e = "👤"; break
              case "exec"     : _e = "⚙️"; break
              case "shell"    : _e = "🖥️"; break
              case "think"    : _e = "💡"; break
              case "final"    : _e = "🏁"; break
              case "input"    : _e = "➡️"; break
              case "output"   : _e = "⬅️"; break
              case "thought"  : _e = "💭"; break
              case "think"    : _e = "💡"; break
              case "size"     : _e = "📏"; break
              case "rate"     : _e = "⏳"; break
              case "mcp"      : _e = "🤖"; break
              case "plan"     : _e = "🗺️"; break
              case "done"     : _e = "✅"; break
              case "error"    : _e = "❌"; break
              case "libs"     : _e = "📚"; break
              case "info"     : _e = "ℹ️"; break
              case "load"     : _e = "📂"; break
              case "mcp"      : _e = "🤖"; break
              case "warn"     : _e = "⚠️"; break
              case "stop"     : _e = "🛑"; break
              case "error"    : _e = "❗"; break
              case "summarize": _e = "🌀"; break
              default         : _e = e
              }

              if (_e == "🗺️") {
                try {
                  if (isFunction(lma._normalizePlanItems)) {
                    var planItems = lma._normalizePlanItems(isObject(lma._agentState) ? lma._agentState.plan : __)
                    if (isArray(planItems) && planItems.length > 0) {
                      var statusIcons = {
                        pending     : { icon: "⏳", label: "pending" },
                        todo        : { icon: "⏳", label: "to do" },
                        not_started : { icon: "⏳", label: "not started" },
                        ready       : { icon: "⏳", label: "ready" },
                        in_progress : { icon: "⚙️", label: "in progress" },
                        progressing : { icon: "⚙️", label: "in progress" },
                        working     : { icon: "⚙️", label: "working" },
                        running     : { icon: "⚙️", label: "running" },
                        active      : { icon: "⚙️", label: "active" },
                        done        : { icon: "✅", label: "done" },
                        complete    : { icon: "✅", label: "complete" },
                        completed   : { icon: "✅", label: "completed" },
                        finished    : { icon: "✅", label: "finished" },
                        success     : { icon: "✅", label: "success" },
                        blocked     : { icon: "🛑", label: "blocked" },
                        stuck       : { icon: "🛑", label: "stuck" },
                        paused      : { icon: "⏸️", label: "paused" },
                        waiting     : { icon: "⏳", label: "waiting" },
                        failed      : { icon: "❌", label: "failed" },
                        cancelled   : { icon: "🚫", label: "cancelled" },
                        canceled    : { icon: "🚫", label: "cancelled" }
                      }
                      var doneStatuses = {
                        done: true,
                        complete: true,
                        completed: true,
                        finished: true,
                        success: true
                      }
                      var normalized = []
                      for (var i = 0; i < planItems.length; i++) {
                        var entry = planItems[i] || {}
                        var statusKey = (entry.status || entry.rawStatus || "").toString()
                        var statusInfo = statusIcons[statusKey] || { icon: "•", label: statusKey || "pending" }
                        var isDone = doneStatuses[statusKey] === true || statusInfo.icon == "✅"
                        normalized.push({
                          title   : entry.title || ("Step " + (i + 1)),
                          status  : statusKey,
                          icon    : statusInfo.icon,
                          label   : statusInfo.label,
                          done    : isDone === true,
                          rawStatus: entry.rawStatus
                        })
                      }
                      var completedCount = 0
                      normalized.forEach(item => { if (item.done === true) completedCount++ })

                      var progressInfo = isObject(lma._planningProgress) ? lma._planningProgress : {}
                      var overallProgress = 0
                      if (isNumber(progressInfo.overall)) {
                        overallProgress = Math.max(0, Math.min(100, Math.round(progressInfo.overall)))
                      } else if (normalized.length > 0) {
                        overallProgress = Math.round((completedCount / normalized.length) * 100)
                      }

                      var checkpointInfo = { reached: 0, total: 0 }
                      if (isObject(progressInfo.checkpoints)) {
                        var checkpoints = progressInfo.checkpoints
                        if (isNumber(checkpoints.reached)) checkpointInfo.reached = checkpoints.reached
                        if (isNumber(checkpoints.total)) checkpointInfo.total = checkpoints.total
                      }

                      global.__planState[uuid] = {
                        items      : normalized,
                        total      : normalized.length,
                        completed  : completedCount,
                        overall    : overallProgress,
                        checkpoints: checkpointInfo,
                        active     : normalized.length > 0,
                        updated    : Date.now()
                      }
                    } else {
                      if (isDef(global.__planState[uuid])) delete global.__planState[uuid]
                    }
                  }
                } catch(planErr) {
                  logErr(planErr)
                }
              //} else if (_e == "🏁" || _e == "✅" || _e == "❌") {
              } else if (_e == "🏁" || _e == "🛑") {
                if (isDef(global.__planState[uuid])) {
                  log(`[${uuid}] ${_e} Plan closed`)
                  delete global.__planState[uuid]
                }
              }
              global.__res[uuid].push({ event: _e, message: m })
              if (isFunction(global._mini_a_web_storeHistory)) {
                try {
                  global._mini_a_web_storeHistory(uuid)
                } catch(syncErr) {
                  logErr(syncErr)
                }
              }
              log("[" + uuid + "] " + _e + " " + m)
            } catch(eee) {
              $err(eee)
              logWarn(`[${uuid}] Plan closed`)
              delete global.__planState[uuid]
            }
          })
          global.__conversations[ uuid ] = lma
        } else {
          lma = global.__conversations[ uuid ]
        }

        var _rma = lma.start(merge(global.maArgs, {
          goal        : postData.prompt,
          raw         : true,
          conversation: global._mini_a_web_loadFile(_hfile)
        }))

        if (isDef(_rma.answer)) {
          var trimmedAnswer = _rma.answer.trim();
          if (trimmedAnswer.startsWith("```markdown") && trimmedAnswer.endsWith("```")) {
            // Remove markdown fences
            _rma.answer = trimmedAnswer.replace(/^```markdown\s*\n?([\s\S]+?)\n?```$/g, "$1").trim()
          }
        }
        global.__res[uuid].push( { event: "final", message: (isObject(_rma) ? af.toSLON(_rma) : _rma) } )
        if (isFunction(global._mini_a_web_storeHistory)) {
          try {
            global._mini_a_web_storeHistory(uuid)
          } catch(storeErr) {
            logErr(storeErr)
          }
        }
        log("[" + uuid + "] " + (isObject(_rma) ? af.toSLON(_rma) : _rma))
      }).catch((eee) => {
        logErr(eee)
        $err(eee)
      })
    } catch(ee) {
      logErr(ee)
      $err(ee)
    }

    return ow.server.httpd.reply(_res)

# Get results of a prompt
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /result
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)

      if (isDef(postData.request) && postData.request == "stop") {
        global.__conversations[ postData.uuid ].state = "stop"
      }
      var _res = { content: "", status: "processing", history: [] }
      var __attachmentLangMap = {
        md: 'markdown', markdown: 'markdown', json: 'json', yaml: 'yaml', yml: 'yaml',
        csv: 'csv', tsv: 'tsv', xml: 'xml', html: 'html', htm: 'html', css: 'css', scss: 'scss', less: 'less',
        js: 'javascript', mjs: 'javascript', cjs: 'javascript', ts: 'typescript', jsx: 'jsx', tsx: 'tsx',
        py: 'python', rb: 'ruby', go: 'go', java: 'java', kt: 'kotlin', c: 'c', h: 'c', cpp: 'cpp', cc: 'cpp', hpp: 'cpp', cs: 'csharp',
        rs: 'rust', php: 'php', sh: 'bash', bash: 'bash', zsh: 'bash', fish: 'bash', sql: 'sql', toml: 'toml', ini: 'ini', cfg: 'ini', conf: 'ini', env: 'ini',
        properties: 'ini', gradle: 'groovy', dockerfile: 'dockerfile', makefile: 'makefile', cmake: 'cmake', r: 'r', lua: 'lua', swift: 'swift', scala: 'scala'
      }

      function __escapeHtml(str) {
        if (isUnDef(str)) return ''
        return ('' + str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;')
      }

      function __escapeAttr(str) {
        return __escapeHtml(str).replace(/[\r\n]+/g, ' ')
      }

      function __detectAttachmentLang(name) {
        if (isUnDef(name)) return 'text'
        var lowered = ('' + name).toLowerCase()
        if (lowered == 'dockerfile') return 'dockerfile'
        if (lowered.indexOf('makefile') == 0) return 'makefile'
        var parts = lowered.split('.')
        var ext = parts.length > 1 ? parts.pop() : ''
        if (isDef(__attachmentLangMap[ext])) return __attachmentLangMap[ext]
        return 'text'
      }

      function __formatUserMessage(message) {
        if (isUnDef(message)) return ''
        var text = '' + message
        var attachments = []
        text = text.replace(/```attachment\s+([^\n]+)\n([\s\S]*?)```/gm, function(_, name, content) {
          var cleanName = ('' + name).replace(/[\r\n]+/g, ' ').trim()
          var cleanContent = ('' + content).replace(/\r\n/g, '\n')
          attachments.push({ name: cleanName, content: cleanContent })
          return '§§ATTACHMENT_' + (attachments.length - 1) + '§§'
        })

        var html = __escapeHtml(text).replace(/\n/g, '<br>')
        for (var j = 0; j < attachments.length; j++) {
          var att = attachments[j]
          var placeholder = '§§ATTACHMENT_' + j + '§§'
          var safeName = att.name && att.name.length > 0 ? att.name : 'attachment.txt'
          var safeNameHtml = __escapeHtml(safeName)
          var attrName = __escapeAttr(safeName)
          var encoded = af.fromBytes2String(af.toBase64Bytes(att.content || ''))
          var language = __detectAttachmentLang(att.name)
          var button = '<button class="user-attachment" type="button" data-name="' + attrName + '" data-language="' + __escapeAttr(language) + '" data-content="' + __escapeAttr(encoded) + '">📎 ' + safeNameHtml + '</button>'
          html = html.replace(placeholder, button)
        }

        return html
      }
      if (isDef(global.__res[ postData.uuid ])) {
        // Update last activity
        global.__lastActivity[ postData.uuid ] = Date.now()
        var planState = isDef(global.__planState) ? global.__planState[ postData.uuid ] : __
        var hasActivePlan = isDef(planState) && isArray(planState.items) && planState.items.length > 0

        // Append all messages to content
        var _history = []
        for (var i = 0; i < global.__res[ postData.uuid ].length; i++) {
          var r = global.__res[ postData.uuid ][i]
          if (isDef(r.event)) {
            var _h = { event: r.event }
            if (isDef(r.message)) _h.message = r.message
            _history.push(_h)
          }
          if (r.event == "final") {
            if (i == global.__res[ postData.uuid ].length - 1) _res.status = "finished"
            _res.content += "\n" + r.message + "\n"
            //delete global.__res[ postData.uuid ]
            //break
          } else {
            // Exclude planning (🗺️) messages from the content log; plan panel remains driven by __planState
            if (r.event == "👤" || (r.event == "⚙️" && global.__showexecs) || (r.event == "🖥️" && global.__showexecs) || r.event == "💡" || r.event == "💭" || r.event == "🌀" || r.event == "🛑" || r.event == "⏳") {
              if (r.event == "👤") {
                _res.content += "<div style=\"text-align: right;\"><i><div style=\"display: inline-block; text-align: left;\">" + __formatUserMessage(r.message) + "</div> " + r.event + "</i>\n<br><br></div>"
              } else {
                _res.content += r.event + " <i><span style=\"color: var(--text); opacity: 0.60;\">" + r.message.replace(/\n/g, "<br>") + "</span></i>\n"
              }
            }
          }
        }
        _res.history = _history
        if (hasActivePlan) {
          _res.plan = {
            active     : true,
            items      : planState.items,
            total      : planState.total,
            completed  : planState.completed,
            overall    : planState.overall,
            checkpoints: planState.checkpoints,
            updated    : planState.updated
          }
        } else {
          _res.plan = {
            active     : false,
            items      : [],
            total      : 0,
            completed  : 0,
            overall    : 0,
            checkpoints: { reached: 0, total: 0 }
          }
        }
      }

      return ow.server.httpd.reply(_res)
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

# Load history for a session
- (httpdService   ): "${onport:-8888}"
  ((uri          )): /load-history
  ((execURI      )): | #js
    try {
      var postData = jsonParse(request.files.postData)

      if (isUnDef(postData.uuid)) {
        return ow.server.httpd.reply({ error: "uuid is required" })
      }

      if (isUnDef(postData.history) || !Array.isArray(postData.history)) {
        return ow.server.httpd.reply({ error: "history must be an array" })
      }

      // If already stored no need to load again
      if (isDef(global.__res[ postData.uuid ])) {
        logWarn("History for " + postData.uuid + " already loaded")
        return ow.server.httpd.reply({ status: "loaded", uuid: postData.uuid, entries: global.__res[ postData.uuid ].length })
      } else {
        logWarn("History for " + postData.uuid + " not found. Rebuilding from provided history with " + postData.history.length + " entries")
      }

      var sanitized = []
      for (var i = 0; i < postData.history.length; i++) {
        var item = postData.history[i]
        if (isUnDef(item) || isUnDef(item.event)) continue
        var entry = { event: item.event }
        if (isDef(item.message)) entry.message = item.message
        sanitized.push(entry)
      }

      global.__res[ postData.uuid ] = sanitized
      delete global.__conversations[ postData.uuid ]
      global.__lastActivity[ postData.uuid ] = Date.now()
      if (isFunction(global._mini_a_web_storeHistory)) {
        try {
          global._mini_a_web_storeHistory(postData.uuid)
        } catch(syncErr) {
          logErr(syncErr)
        }
      }

      return ow.server.httpd.reply({ status: "loaded", uuid: postData.uuid, entries: sanitized.length })
    } catch(e) {
      printErr(e)
      return ow.server.httpd.reply({ error: e.toString() })
    }

ojob:
  opacks      :
  - openaf: 20250915
  - oJob-common
  - mini-a
  - S3
  catch       : printErrnl("[" + job.name + "] "); $err(exception, __, __, job.exec)
  logToConsole: true   # to change when finished
  daemon      : true
  argsFromEnvs: true
  loadLibs    :
  - mini-a.js
  - s3.js
  channels    :
    create:
    - name: conversations
    - name: lastActivity
    - name: results

jobs:
# ---------------------
- name : Static content
  exec : | #js
    args.path = getOPackPath("mini-a") + "/public"
  to   :
  - (httpdFileBrowse): "${onport:-8888}"
    ((uri          )): /
    #((path         )): public
    ((browse       )): false
    ((default      )): index.md

# -----------
- name : Init
  check:
    in:
      showexecs       : toBoolean().isBoolean().default(false)
      logpromptheaders: isString().default("")
      maxcontext      : toNumber().isNumber().default(200000)
      usehistory      : toBoolean().isBoolean().default(false)
      useattach       : toBoolean().isBoolean().default(false)
      historypath     : isString().default(".")
      historykeep     : toBoolean().isBoolean().default(false)
      useplanning     : toBoolean().isBoolean().default(false)
      usediagrams     : toBoolean().isBoolean().default(true)
      usecharts       : toBoolean().isBoolean().default(true)
      historys3bucket : isString().default(__)
      historys3prefix : isString().default("")
      historys3url    : isString().default("https://s3.amazonaws.com")
      historys3accesskey: isString().default(__)
      historys3secret : isString().default(__)
      historys3region : isString().default(__)
      historys3useversion1: toBoolean().isBoolean().default(false)
      historys3ignorecertcheck: toBoolean().isBoolean().default(false)
  exec : | #js
    global.__res = {}
    global.__usehistory = args.usehistory
    global.__historypath = args.historypath
    global.__historykeep = args.historykeep
    global.__conversations = {}
    global.__lastActivity = { }
    global.__showexecs = args.showexecs
    global.__logpromptheaders = args.logpromptheaders.split(",").map(h => h.trim().toLowerCase()).filter(h => h.length > 0)
    global.__useattach = args.useattach
    global.__planState = {}
    if (global.__usehistory && isString(global.__historypath)) {
      try {
        io.mkdir(global.__historypath)
      } catch(ignore) {}
    }

    global.__historys3bucket = args.historys3bucket
    global.__historys3client = __
    global.__historys3enabled = false
    global.__historys3prefix = isString(args.historys3prefix) ? String(args.historys3prefix) : ""
    if (global.__historys3prefix.length > 0) {
      while (global.__historys3prefix.charAt(0) == "/") {
        global.__historys3prefix = global.__historys3prefix.substring(1)
      }
      while (global.__historys3prefix.length > 0 && global.__historys3prefix.charAt(global.__historys3prefix.length - 1) == "/") {
        global.__historys3prefix = global.__historys3prefix.substring(0, global.__historys3prefix.length - 1)
      }
    }

    if (global.__usehistory && isString(global.__historys3bucket) && global.__historys3bucket.length > 0) {
      try {
        global.__historys3client = new S3(args.historys3url, args.historys3accesskey, args.historys3secret, args.historys3region, args.historys3useversion1, args.historys3ignorecertcheck)
        global.__historys3enabled = true
        log("History S3 storage enabled for bucket " + global.__historys3bucket + (global.__historys3prefix.length > 0 ? (" with prefix " + global.__historys3prefix) : ""))
      } catch(initErr) {
        logErr(initErr)
        global.__historys3client = __
        global.__historys3enabled = false
      }
    }

    args.__format = "md"
    
    // Add system knowledge about visual diagram capabilities
    var visualDiagramKnowledge = ""
    var visualParts = []
    
    if (args.usediagrams || args.usecharts) {
      visualParts.push(
        "Visual output guidance (concise):\n\n" +
        "- Default to including a diagram or chart whenever structure, flow, hierarchy, metrics, or comparisons are involved.\n" +
        "- Always pair the visual with a short caption (1-2 sentences) summarizing the insight.\n" +
        "- Never mention the technical implementation (Mermaid, Chart.js, etc.) to users; refer only to 'diagrams' and 'charts'."
      )
    }
    
    if (args.usediagrams) {
      visualParts.push(
        "Diagrams:\n" +
        "  - Use ```mermaid``` fences for flows (`graph TD`), sequenceDiagram, stateDiagram-v2, classDiagram, erDiagram, gantt, mindmap, or pie charts.\n" +
        "  - Keep node labels concise and prefer directional edges for processes.\n" +
        "  - CRITICAL: Always wrap all labels in double quotes (e.g., A[\"Label text\"] not A[Label text]) to avoid syntax errors."
      )
    }
    
    if (args.usecharts) {
      visualParts.push(
        "Charts (strict format):\n" +
        "  - Wrap only the config object inside ```chart``` (aliases: chartjs, chart.js).\n" +
        "  - Include `type`, `data.labels`, and at least one dataset; add palettes and `options` as needed.\n" +
        "  - Optional `canvas: { width, height }` block controls sizing when helpful.\n" +
        "  - Never use other fences (json/javascript) and never return raw JSON.\n" +
        "  - Use only static values; do not include functions or dynamic callbacks (no `ctx => ...`, no `function(){}`); configs are treated as data and code is not executed.\n" +
        "  - Provide complete, deterministic data inline (no async or fetching).\n" +
        "  - IMPORTANT: When working with datetime values, keep them as strings in ISO format or as timestamp numbers. Do not use Date objects or date parsing functions in the chart configuration.\n\n" +
        "Available chart plugins/types (preloaded):\n" +
        "  - chartjs-adapter-date-fns (time scale; use scales.{x|y}.type='time' with ISO date strings)\n" +
        "  - @sgratzl/chartjs-chart-boxplot (types: 'boxplot', 'violin')\n" +
        "  - chartjs-chart-treemap (type: 'treemap')\n" +
        "  - chartjs-chart-sankey (type: 'sankey')\n" +
        "  - chartjs-chart-matrix (type: 'matrix')\n" +
        "  - chartjs-chart-graph (type: 'graph')\n" +
        "  - chartjs-chart-geo (types: 'choropleth', 'bubbleMap')"
      )
    }
    
    if (args.usediagrams || args.usecharts) {
      var checklist = "\n\nVisual selection checklist:"
      if (args.usediagrams) {
        checklist += "\n1. Relationships or flows -> diagram with graph or sequence."
        checklist += "\n2. Timelines or roadmaps -> diagram with gantt."
      }
      if (args.usecharts) {
        checklist += "\n" + (args.usediagrams ? "3" : "1") + ". Comparisons or trends -> bar or line chart."
        checklist += "\n" + (args.usediagrams ? "4" : "2") + ". Composition or ratios -> pie or doughnut chart."
      }
      checklist += "\n\nIf a visual truly does not apply (e.g., purely narrative requests), explain why before falling back to text-only output."
      visualParts.push(checklist)
    }
    
    visualDiagramKnowledge = visualParts.join("\n\n")

    if (visualDiagramKnowledge.length > 0) {
      if (isUnDef(args.knowledge)) {
        args.knowledge = visualDiagramKnowledge
      } else {
        args.knowledge = args.knowledge + "\n\n" + visualDiagramKnowledge
      }
    }
    
    global.maArgs = merge(args, {})
    if (!toBoolean(args.mcplazy)) {
      var _ma = new MiniA()
      _ma.init( global.maArgs )
      _ma = __
    }

    global._mini_a_web_historyS3Key = (uuid) => {
      if (isUnDef(uuid)) return __
      var clean = String(uuid)
      var key = "c-" + clean + ".json"
      if (global.__historys3prefix.length > 0) {
        key = global.__historys3prefix + "/" + key
      }
      return key
    }

    global._mini_a_web_uuidFromPath = (aFile) => {
      if (isUnDef(aFile) || isUnDef(global.__historypath)) return __
      var base = String(global.__historypath)
      if (base.length > 0 && base.charAt(base.length - 1) != "/") {
        base = base + "/"
      }
      var prefix = base + "c-"
      var file = String(aFile || "")
      if (file.indexOf(prefix) == 0 && file.length > prefix.length + 5) {
        var uuid = file.substring(prefix.length)
        if (uuid.endsWith(".json")) {
          uuid = uuid.substring(0, uuid.length - 5)
        }
        return uuid
      }
      return __
    }

    global._mini_a_web_buildHistoryPayload = (uuid) => {
      if (isUnDef(uuid)) return __
      var hfile = global.__historypath + "/c-" + uuid + ".json"

      // Prefer S3 when enabled
      if (global.__historys3enabled) {
        var stream, str
        try {
          var key = global._mini_a_web_historyS3Key(uuid)
          log("S3 history get (payload) bucket=" + global.__historys3bucket + " key=" + key)
          stream = global.__historys3client.getObjectStream(global.__historys3bucket, key)
          str = af.fromInputStream2String(stream)
        } catch(getErr) {
          // Ignore missing objects; log other errors
          if (isDef(getErr) && String(getErr).indexOf("NoSuchKey") < 0) {
            logErr(getErr)
          }
        } finally {
          if (isDef(stream)) { try { stream.close() } catch(ignore) {} }
        }
        if (isDef(str)) {
          try {
            log("S3 history got payload for uuid=" + uuid + " size=" + str.length)
            return str
          } catch(convErr) { logErr(convErr) }
        }
      }

      // Otherwise try local file if present
      if (io.fileExists(hfile)) {
        try {
          return io.readFileString(hfile)
        } catch(readErr) {
          logErr(readErr)
        }
      }

      // Build from in-memory events
      if (isDef(global.__res[uuid]) && isArray(global.__res[uuid]) && global.__res[uuid].length > 0) {
        var data = []
        for (var i = 0; i < global.__res[uuid].length; i++) {
          var entry = global.__res[uuid][i]
          if (isUnDef(entry) || isUnDef(entry.event)) continue
          var msg = isDef(entry.message) ? entry.message : ""
          switch(entry.event) {
          case "👤":
            data.push({ role: "user", content: msg })
            break
          case "🤖":
          case "⬅️":
          case "🏁":
          case "✅":
          case "❌":
            data.push({ role: "assistant", content: msg })
            break
          case "⚙️":
          case "🖥️":
          case "📚":
          case "ℹ️":
          case "📂":
          case "⚠️":
          case "🛑":
            data.push({ role: "system", content: msg })
            break
          default:
            // Skip remaining events from being persisted
          }
        }
        if (data.length > 0) {
          return stringify({ u: new Date(), c: data }, __, "")
        }
      }
      return __
    }

    global._mini_a_web_storeHistory = (uuid) => {
      if (!global.__historys3enabled) return
      var payload = global._mini_a_web_buildHistoryPayload(uuid)
      if (isUnDef(payload)) return
      var stream, bytes
      try {
        var key = global._mini_a_web_historyS3Key(uuid)
        log("S3 history put bucket=" + global.__historys3bucket + " key=" + key + " size=" + (isDef(payload) ? payload.length : 0))
        global.__historys3client.putObjectStream(global.__historys3bucket, key, af.fromString2InputStream(payload), {}, "application/json")
      } catch(storeErr) {
        logErr(storeErr)
      } finally {
        if (isDef(stream)) {
          try { stream.close() } catch(ignore) {}
        }
      }
    }

    global._mini_a_web_deleteHistory = (uuid) => {
      if (isUnDef(uuid)) return
      var localFile = isString(global.__historypath) ? (global.__historypath + "/c-" + uuid + ".json") : __
      // Remove remote if enabled
      if (global.__historys3enabled) {
        try {
          var key = global._mini_a_web_historyS3Key(uuid)
          log("S3 history delete bucket=" + global.__historys3bucket + " key=" + key)
          global.__historys3client.removeObject(global.__historys3bucket, key)
        } catch(removeErr) {
          logErr(removeErr)
        }
      }
      // Always try to remove local cache file if present
      if (isString(localFile) && io.fileExists(localFile)) {
        try { io.rm(localFile) } catch(ignore) {}
      }
    }

    global._mini_a_web_saveFile = (aFile, aMap) => {
      var uuid = global._mini_a_web_uuidFromPath(aFile)
      if (global.__historys3enabled && isDef(uuid)) {
        // Save to S3 instead of local
        var payload
        try {
          payload = stringify(aMap, __, "")
        } catch(jsonErr) { logErr(jsonErr); return }
        var stream, bytes
        try {
          var key = global._mini_a_web_historyS3Key(uuid)
          bytes = af.fromString2Bytes(payload, "utf-8")
          log("S3 history save bucket=" + global.__historys3bucket + " key=" + key + " size=" + (isDef(bytes) ? bytes.length : 0))
          stream = new Packages.java.io.ByteArrayInputStream(bytes)
          global.__historys3client.putObjectStream(global.__historys3bucket, key, stream, {}, "application/json")
        } catch(storeErr) {
          logErr(storeErr)
        } finally {
          if (isDef(stream)) { try { stream.close() } catch(ignore) {} }
        }
      } else {
        // Local save
        try { io.writeFileJSON(aFile, aMap, "") } catch(writeErr) { logErr(writeErr) }
      }
    }

    global._mini_a_web_historyExists = (uuid) => {
      if (isUnDef(uuid)) return false
      var localFile = isString(global.__historypath) ? (global.__historypath + "/c-" + uuid + ".json") : __
      if (global.__historys3enabled) {
        var stream
        try {
          var key = global._mini_a_web_historyS3Key(uuid)
          log("S3 history exists? bucket=" + global.__historys3bucket + " key=" + key)
          stream = global.__historys3client.getObjectStream(global.__historys3bucket, key)
          log("S3 history exists: true for key=" + key)
          return true
        } catch(getErr) {
          // Missing object is not an error
          try { if (String(getErr).indexOf("NoSuchKey") >= 0) log("S3 history exists: false for key=" + global._mini_a_web_historyS3Key(uuid)) } catch(ignore) {}
          return false
        } finally {
          if (isDef(stream)) { try { stream.close() } catch(ignore) {} }
        }
      }
      return isString(localFile) && io.fileExists(localFile)
    }

    global._mini_a_web_loadFile = (aFile) => {
      // Can be __
      if (global.__historys3enabled && isString(aFile)) {
        var uuid = global._mini_a_web_uuidFromPath(aFile)
        if (isDef(uuid)) {
          var stream, str
          try {
            var key = global._mini_a_web_historyS3Key(uuid)
            log("S3 history get (load) bucket=" + global.__historys3bucket + " key=" + key + " -> file=" + aFile)
            stream = global.__historys3client.getObjectStream(global.__historys3bucket, key)
            str = af.fromInputStream2String(stream)
          } catch(getErr) {
            // Ignore missing objects
            if (isDef(getErr) && String(getErr).indexOf("NoSuchKey") < 0) {
              logErr(getErr)
            }
          } finally {
            if (isDef(stream)) {
              try { stream.close() } catch(ignore) {}
            }
          }
          if (isDef(str)) {
            try {
              log("S3 history downloaded uuid=" + uuid + " size=" + str.length + " -> " + aFile)
              io.writeFileString(aFile, str)
            } catch(writeErr) {
              logErr(writeErr)
            }
          }
        }
      }
      return aFile
    }

# ---------------------------------------
- name : Periodic cleanup of old sessions
  type : periodic
  typeArgs:
    interval: 300000  # every 5 minutes
  args :
    historyretention: toNumber().isNumber().default(600)  # 10 minutes
  exec : | #js
    var toDelete = []
    for (var uuid in global.__lastActivity) {
      // If no activity for more than 5 minutes, delete session
      if (now() - global.__lastActivity[ uuid ] > args.historyretention * 1000) {
        toDelete.push(uuid)
      }
    }
    for (var i = 0; i < toDelete.length; i++) {
      var uuid = toDelete[i]
      delete global.__lastActivity[ uuid ]
      delete global.__res[ uuid ]
      delete global.__conversations[ uuid ]
      if (isDef(global.__planState) && isDef(global.__planState[ uuid ])) delete global.__planState[ uuid ]
      if (global.__usehistory && !global.__historykeep && isFunction(global._mini_a_web_deleteHistory)) {
        try {
          global._mini_a_web_deleteHistory(uuid)
        } catch(cleanErr) {
          logErr(cleanErr)
        }
      }
      log("Cleaned up session " + uuid)
    }

# ---------------------------------------
- name : Shutdown history S3 client
  type : shutdown
  exec : | #js
    if (isDef(global.__historys3client)) {
      try { global.__historys3client.close() } catch(ignore) {}
      global.__historys3client = __
      global.__historys3enabled = false
    }
