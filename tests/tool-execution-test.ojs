loadLib('mini-a.js')
ow.loadTest()

(function() {
  function cloneMap(map) {
    if (!isMap(map)) return {}
    var copy = {}
    Object.keys(map).forEach(function(key) {
      copy[key] = map[key]
    })
    return copy
  }

  function createTestAgent(options) {
    var opts = isMap(options) ? options : {}
    var agent = new MiniA()
    agent.fnI = function() {}
    agent._useTools = false
    agent._toolInfoByName = {}

    var finalizeLog = []
    agent._finalizeToolExecution = function(payload) {
      finalizeLog.push(payload)
    }

    agent._prepareToolExecution = function(info) {
      var base = isMap(info) ? info : {}
      base.contextId = base.contextId || genUUID()
      base.fromCache = false
      return base
    }

    var connectionId = isString(opts.connectionId) ? opts.connectionId : 'conn1'
    var executionDelay = isNumber(opts.executionDelay) ? opts.executionDelay : 600

    var callLog = []
    var client = {
      __miniAOriginalCallTool: function(name, params) {
        callLog.push({ name: name, params: params, ts: now() })
        java.lang.Thread.sleep(executionDelay)
        return { ok: true, tool: name, params: params }
      },
      callTool: function(name, params) {
        return this.__miniAOriginalCallTool(name, params)
      },
      initialize: function() {}
    }

    agent._mcpConnections[connectionId] = client
    agent._lazyMcpConnections[connectionId] = false

    var tools = isArray(opts.tools) && opts.tools.length > 0 ? opts.tools : ['toolA', 'toolB']
    tools.forEach(function(tool) {
      agent.mcpToolToConnection[tool] = connectionId
    })

    var cacheSettings = cloneMap(opts.cacheSettings)
    tools.forEach(function(tool, idx) {
      if (isUnDef(cacheSettings[tool])) {
        cacheSettings[tool] = {
          enabled  : idx === 0,
          ttl      : 120000,
          keyFields: []
        }
      }
    })
    agent._toolCacheSettings = cacheSettings

    return {
      agent        : agent,
      callLog      : callLog,
      finalizeLog  : finalizeLog,
      executionDelay: executionDelay
    }
  }

  exports.testParallelExecutionAndCaching = function() {
    var ctx = createTestAgent({
      tools        : ['toolA', 'toolB'],
      cacheSettings: {
        toolA: { enabled: true, ttl: 120000, keyFields: [] },
        toolB: { enabled: false }
      },
      executionDelay: 300
    })

    var agent = ctx.agent
    var start = now()
    var results = agent._executeParallelToolBatch([
      { toolName: 'toolA', params: { value: 1 }, stepLabel: '1.1', updateContext: true },
      { toolName: 'toolB', params: { value: 2 }, stepLabel: '1.2', updateContext: true }
    ])
    var elapsed = now() - start

    ow.test.assert(results.length, 2, 'Should return one result per requested tool')
    ow.test.assert(ctx.callLog.length, 2, 'Each tool should be invoked exactly once')
    var sequentialThreshold = Math.round(ctx.executionDelay * 1.8)
    ow.test.assert(elapsed < sequentialThreshold, true, 'Parallel execution should finish faster than sequential (elapsed: ' + elapsed + 'ms, threshold: ' + sequentialThreshold + 'ms)')
    ow.test.assert(ctx.finalizeLog.length, 2, 'Finalize hook should run once per tool')

    var cachedResults = agent._executeParallelToolBatch([
      { toolName: 'toolA', params: { value: 1 }, stepLabel: '2.1', updateContext: true }
    ])

    ow.test.assert(cachedResults.length, 1, 'Cached call should still return aggregated result')
    ow.test.assert(ctx.callLog.length, 2, 'Cached result should reuse previous tool output')
    ow.test.assert(cachedResults[0].fromCache, true, 'Result metadata should flag cache hits')

    var lastFinalize = ctx.finalizeLog[ctx.finalizeLog.length - 1]
    ow.test.assert(lastFinalize.context.fromCache, true, 'Finalize payload should expose cache usage')
    ow.test.assert(lastFinalize.result.ok, true, 'Cached raw result should match prior execution')
  }

  exports.testUnknownToolReportsError = function() {
    var ctx = createTestAgent({
      tools        : ['toolA'],
      cacheSettings: { toolA: { enabled: false } },
      executionDelay: 100
    })

    var results = ctx.agent._executeParallelToolBatch([
      { toolName: 'missingTool', params: { value: 5 }, stepLabel: 'err-1', updateContext: true }
    ])

    ow.test.assert(results.length, 1, 'Unknown tool should yield a single result entry')
    ow.test.assert(results[0].error, true, 'Unknown tool should be marked as error')
    ow.test.assert(results[0].result.error, "Unknown tool 'missingTool'.", 'Error message should reference missing tool')
    ow.test.assert(ctx.callLog.length, 0, 'Unknown tools must not call any MCP client')

    var finalizePayload = ctx.finalizeLog[0]
    ow.test.assert(finalizePayload.error, true, 'Finalize payload should flag errors')
    ow.test.assert(finalizePayload.observation, "Unknown tool 'missingTool'.", 'Finalize observation should echo the error message')
  }
})()
